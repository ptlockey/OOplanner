
    <style>
    :root {
        color-scheme: light;
    }
    html, body {
        min-height: 100vh;
    }
    body {
        margin: 0;
        font-family: 'Source Sans Pro', sans-serif;
        background: linear-gradient(180deg, #eef1f5 0%, #e2e7f0 100%);
        display: flex;
        justify-content: center;
        padding: 1.5rem;
        box-sizing: border-box;
    }
    .designer-wrapper {
        display: grid;
        grid-template-columns: minmax(260px, 1fr) minmax(0, 3fr);
        gap: 1.25rem;
        align-items: start;
        width: 100%;
        max-width: 1480px;
        flex: 1 1 auto;
        min-height: 0;
        overflow: visible;
    }
    .board-column {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        flex: 1 1 auto;
        min-height: 0;
    }
    .board-canvas {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        flex: 1;
        min-height: 0;
    }
    .board-surface {
        position: relative;
        border: 2px solid #d0d0d0;
        border-radius: 0.5rem;
        background: #ffffff;
        overflow: hidden;
        min-height: 580px;
        height: min(900px, 72vh);
        flex: 1;
        box-shadow: 0 10px 28px rgba(31, 55, 90, 0.12);
    }
    #boardCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
        display: block;
    }
    .view-controls,
    .board-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
    }
    .view-controls label,
    .board-controls span.label {
        font-weight: 600;
        font-size: 0.9rem;
    }
    .view-controls input[type="range"] {
        flex: 1;
        min-width: 160px;
    }
    .view-controls span,
    .board-controls span.value {
        min-width: 3rem;
        text-align: right;
        font-variant-numeric: tabular-nums;
    }
    .view-controls button,
    .board-controls button {
        padding: 0.3rem 0.75rem;
        border-radius: 0.4rem;
        border: 1px solid #666666;
        background: #f8f8f8;
        cursor: pointer;
    }
    .board-controls {
        justify-content: flex-start;
    }
    .board-controls span.value {
        font-weight: 600;
    }
    .piece-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
    }
    .piece-controls button {
        padding: 0.4rem 0.75rem;
        border-radius: 0.4rem;
        border: 1px solid #666666;
        background: #f2f2f2;
        cursor: pointer;
    }
    .piece-controls button.primary {
        border-color: #1f77b4;
        background: #1f77b4;
        color: white;
    }
    .piece-controls span {
        font-weight: 600;
    }
    .hint {
        font-size: 0.85rem;
        color: #555555;
    }
    .export-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.5rem;
    }
    .export-controls button {
        padding: 0.45rem 0.9rem;
        border-radius: 0.4rem;
        border: 1px solid #1f77b4;
        background: #1f77b4;
        color: #ffffff;
        cursor: pointer;
        font-weight: 600;
    }
    .export-controls .hint {
        margin: 0;
    }
    .library-panel {
        border: 1px solid #d0d0d0;
        border-radius: 0.75rem;
        background: #f8f9fb;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        position: sticky;
        top: 1.5rem;
        max-height: calc(100vh - 3rem);
        overflow: auto;
        align-self: start;
    }
    .library-panel h3 {
        margin: 0;
        font-size: 1.1rem;
    }
    .library-sections {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }
    .library-section {
        border: 1px solid #d0d0d0;
        border-radius: 0.65rem;
        background: #ffffff;
        overflow: hidden;
    }
    .library-section summary {
        cursor: pointer;
        list-style: none;
        padding: 0.75rem 0.95rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        font-weight: 600;
        background: linear-gradient(180deg, rgba(238, 241, 245, 0.75) 0%, rgba(222, 228, 237, 0.75) 100%);
    }
    .library-section summary .label {
        color: #2f3b52;
        font-size: 0.95rem;
    }
    .library-section summary::after {
        content: "â–¾";
        font-size: 0.9rem;
        color: #4d5b75;
        margin-left: auto;
        transition: transform 0.2s ease;
    }
    .library-section summary::-webkit-details-marker {
        display: none;
    }
    .library-section summary .count {
        font-size: 0.85rem;
        color: #4d5b75;
        background: rgba(79, 129, 189, 0.16);
        padding: 0.1rem 0.5rem;
        border-radius: 999px;
        font-weight: 600;
    }
    .library-section[open] summary {
        background: linear-gradient(180deg, rgba(219, 229, 241, 0.9) 0%, rgba(206, 219, 236, 0.9) 100%);
        border-bottom: 1px solid #d0d0d0;
    }
    .library-section[open] summary::after {
        transform: rotate(180deg);
    }
    .library-section .library-grid {
        padding: 0.9rem;
        display: grid;
        gap: 0.6rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .library-item {
        border: 1px solid #d7d7d7;
        border-radius: 0.45rem;
        padding: 0.6rem;
        background: #ffffff;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
    }
    .library-heading {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 0.5rem;
    }
    .library-heading span {
        font-size: 0.9rem;
        color: #444444;
    }
    .library-item small {
        color: #666666;
    }
    .library-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
    }
    .library-actions button {
        flex: 1 1 auto;
        padding: 0.35rem 0.5rem;
        border-radius: 0.3rem;
        border: 1px solid #1f77b4;
        background: #1f77b4;
        color: white;
        cursor: pointer;
        font-size: 0.85rem;
    }
    .library-actions button.add-circle {
        border-color: #9467bd;
        background: #9467bd;
    }
    .circle-panel {
        margin-top: 1rem;
        border-top: 1px solid #d0d0d0;
        padding-top: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    .planning-panel {
        margin-top: 1rem;
        border: 1px solid #d0d0d0;
        border-radius: 0.75rem;
        background: #ffffff;
        padding: 1rem 1.2rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        box-shadow: 0 10px 28px rgba(31, 55, 90, 0.12);
    }
    .planning-panel h4 {
        margin: 0;
        font-size: 1.05rem;
        color: #2f3b52;
    }
    .circle-list {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
    }
    .planning-panel .circle-list {
        max-height: 320px;
        overflow: auto;
        padding-right: 0.25rem;
    }
    .circle-item {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.5rem;
        border: 1px solid #d7d7d7;
        border-radius: 0.45rem;
        padding: 0.4rem 0.6rem;
        background: #ffffff;
    }
    .circle-item.selected {
        border-color: #9467bd;
        box-shadow: 0 0 0 2px rgba(148, 103, 189, 0.25);
    }
    .circle-swatch {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(0, 0, 0, 0.1);
    }
    .circle-meta {
        flex: 1 1 auto;
        min-width: 160px;
        font-size: 0.85rem;
    }
    .circle-actions button {
        padding: 0.3rem 0.6rem;
        border-radius: 0.3rem;
        border: 1px solid #d62728;
        background: #d62728;
        color: white;
        cursor: pointer;
        font-size: 0.8rem;
    }
    @media (max-width: 1100px) {
        body {
            overflow: auto;
            padding: 1rem;
        }
        .designer-wrapper {
            display: flex;
            flex-direction: column;
            height: auto;
        }
        .board-column {
            height: auto;
        }
        .library-panel {
            position: static;
            max-height: none;
        }
    }
    </style>
    <div class="designer-wrapper">
        <aside class="library-panel">
            <h3>Track library</h3>
            <p class="hint">Click "Add to board" to drop a piece onto the layout.</p>
            <div class="library-sections" id="librarySections"></div>
        </aside>
        <div class="board-column">
            <div class="board-canvas">
                <div class="board-surface">
                    <canvas id="boardCanvas"></canvas>
                </div>
                <div class="view-controls">
                    <label for="zoomSlider">Zoom</label>
                    <input type="range" id="zoomSlider" min="0.4" max="3" step="0.01" value="1" />
                    <span id="zoomValue">100%</span>
                    <button id="resetView" type="button">Reset view</button>
                </div>
                <div class="board-controls">
                    <span class="label">Board orientation</span>
                    <button id="boardRotateLeft" type="button">â†º 90Â°</button>
                    <button id="boardRotateRight" type="button">â†» 90Â°</button>
                    <span class="value" id="boardOrientationLabel">0Â°</span>
                </div>
                <div class="piece-controls">
                    <span id="selectionLabel">No piece selected</span>
                    <button id="rotateLeft">âŸ² Rotate -15Â°</button>
                    <button id="rotateRight">âŸ³ Rotate +15Â°</button>
                    <button id="flipPiece">Flip</button>
                    <button id="nudgeUp">â–² Nudge</button>
                    <button id="nudgeDown">â–¼ Nudge</button>
                    <button id="nudgeLeft">â—€ Nudge</button>
                    <button id="nudgeRight">â–¶ Nudge</button>
                    <button id="snapPiece" class="primary">Snap to piece</button>
                    <button id="snapGrid">Snap to 10 mm</button>
                    <button id="toggleSectionMode">Section move: Off</button>
                    <button id="deletePiece">ðŸ—‘ Remove</button>
                </div>
                <p class="hint">Tip: drag pieces directly on the board. Use "Snap to piece" to connect endpoints, or toggle section move to reposition an entire connected run.</p>
                <div class="export-controls">
                    <button id="saveLayout" type="button">ðŸ’¾ Save layout</button>
                    <p class="hint">Download a JSON backup of the current plan.</p>
                </div>
            </div>
        </div>
    </div>
    <script src="https://unpkg.com/streamlit-component-lib/dist/index.js"></script>
    <script>
    let boardData = { polygon: [], description: '', orientation: 0 };
    let trackLibrary = [];
    let libraryByCode = {};
    let placements = [];
    let guideCircles = [];
    let nextId = 0;
    let selectedId = null;
    let selectedCircleId = null;
    let boardOrientation = 0;
    let zoom = 1;
    let pan = { x: 0, y: 0 };
    const colorPalette = ['#ff7f0e', '#9467bd', '#2ca02c', '#d62728', '#17becf', '#1f77b4'];
    const queryParams = new URLSearchParams(window.location.search);
    const componentId = queryParams.get('componentId');

    const padding = 60;
    const EXPANDED_SECTIONS_STORAGE_KEY = 'layoutDesignerExpandedSections';
    const GUIDE_CIRCLE_HANDLE_MIN_RADIUS_MM = 8;
    const GUIDE_CIRCLE_HANDLE_MAX_RADIUS_MM = 24;
    const GUIDE_CIRCLE_HANDLE_RADIUS_RATIO = 0.35;

    function loadExpandedSections() {
        const globalStore = window.__layoutDesignerExpandedSections;
        if (globalStore instanceof Set) {
            return globalStore;
        }
        let fromStorage = null;
        try {
            const stored = window.localStorage && window.localStorage.getItem(EXPANDED_SECTIONS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    fromStorage = new Set(parsed.map(value => String(value)));
                }
            }
        } catch (error) {
            fromStorage = null;
        }
        const initial = fromStorage instanceof Set ? fromStorage : new Set();
        window.__layoutDesignerExpandedSections = initial;
        return initial;
    }

    const expandedLibrarySections = loadExpandedSections();

    function persistExpandedSections() {
        try {
            if (window.localStorage) {
                const payload = JSON.stringify(Array.from(expandedLibrarySections));
                window.localStorage.setItem(EXPANDED_SECTIONS_STORAGE_KEY, payload);
            }
        } catch (error) {
            // Ignore persistence errors (e.g., private mode restrictions)
        }
    }

    function clonePoint(point) {
        if (Array.isArray(point) && point.length >= 2) {
            const x = Number(point[0]);
            const y = Number(point[1]);
            return [Number.isFinite(x) ? x : 0, Number.isFinite(y) ? y : 0];
        }
        if (point && typeof point === 'object') {
            const x = Number(point.x);
            const y = Number(point.y);
            return [Number.isFinite(x) ? x : 0, Number.isFinite(y) ? y : 0];
        }
        return [0, 0];
    }

    function defaultPolygon() {
        return [[0, 0], [2400, 0], [2400, 1200], [0, 1200]];
    }

    let polygon = (boardData.polygon && boardData.polygon.length ? boardData.polygon : defaultPolygon()).map(clonePoint);
    let minX = 0;
    let maxX = 0;
    let minY = 0;
    let maxY = 0;
    let widthMm = 1;
    let heightMm = 1;
    let boardCenter = { x: 0, y: 0 };

    const CATEGORY_SPECS = [
        { name: 'Straights & Flex', kinds: ['straight', 'flex'] },
        { name: 'Curves', kinds: ['curve'] },
        { name: 'Points & Turnouts', kinds: ['point'] },
        { name: 'Special Pieces', kinds: null },
    ];

    function renderLibrarySections() {
        const container = document.getElementById('librarySections');
        if (!container) { return; }
        if (!Array.isArray(trackLibrary)) {
            trackLibrary = [];
        }
        const categories = CATEGORY_SPECS.map(spec => ({ name: spec.name, items: [] }));
        const byName = new Map(categories.map(cat => [cat.name, cat]));
        const fallback = CATEGORY_SPECS.find(spec => !spec.kinds) || CATEGORY_SPECS[CATEGORY_SPECS.length - 1];
        trackLibrary.forEach(item => {
            if (!item || typeof item !== 'object') { return; }
            const kind = item.kind;
            let target = CATEGORY_SPECS.find(spec => Array.isArray(spec.kinds) && spec.kinds.includes(kind));
            if (!target) {
                target = fallback;
            }
            if (!target) { return; }
            byName.get(target.name).items.push(item);
        });
        let markup = '';
        const shouldDefaultOpenFirst = expandedLibrarySections.size === 0;
        let firstOpen = true;
        categories.forEach(spec => {
            const entry = byName.get(spec.name);
            if (!entry || !entry.items.length) { return; }
            const cards = entry.items.map(item => {
                const radius = typeof item.radius === 'number' ? item.radius : null;
                const radiusFragment = radius ? ` Â· Radius ${radius.toFixed(0)} mm` : '';
                const kindLabel = item.kind ? String(item.kind).charAt(0).toUpperCase() + String(item.kind).slice(1) : '';
                const lengthValue = item.displayLength ?? item.length ?? 0;
                return (
                    `<div class="library-item">` +
                    `<div class="library-heading"><strong>${item.code}</strong><span>${item.name || ''}</span></div>` +
                    `<small>${kindLabel} Â· ${Number(lengthValue).toFixed(0)} mm${radiusFragment}</small>` +
                    `<div class="library-actions">` +
                    `<button data-code="${item.code}" class="add-piece">Add to board</button>` +
                    `</div>` +
                    `</div>`
                );
            }).join('');
            const isOpen = expandedLibrarySections.has(spec.name) || (shouldDefaultOpenFirst && firstOpen);
            const openAttr = isOpen ? ' open' : '';
            if (isOpen) {
                expandedLibrarySections.add(spec.name);
            }
            firstOpen = false;
            markup += `<details class="library-section" data-section="${spec.name}"${openAttr}>` +
                `<summary><span class="label">${spec.name}</span><span class="count">${entry.items.length}</span></summary>` +
                `<div class="library-grid">${cards}</div>` +
                `</details>`;
        });
        if (!markup) {
            container.innerHTML = '<p class="hint">Track library is unavailable.</p>';
            return;
        }
        container.innerHTML = markup;
        persistExpandedSections();
        requestFrameHeight();
        container.querySelectorAll('.library-section').forEach(section => {
            section.addEventListener('toggle', () => {
                const sectionName = section.getAttribute('data-section');
                if (sectionName) {
                    if (section.open) {
                        expandedLibrarySections.add(sectionName);
                    } else {
                        expandedLibrarySections.delete(sectionName);
                    }
                    persistExpandedSections();
                }
                requestAnimationFrame(() => requestFrameHeight());
            });
        });
        container.querySelectorAll('.add-piece').forEach(button => {
            button.addEventListener('click', event => {
                const code = event.currentTarget.getAttribute('data-code');
                if (code) {
                    addPiece(code);
                }
            });
        });
    }

    function recalculateBoardGeometry() {
        if (!polygon.length) {
            polygon = defaultPolygon();
        }
        polygon = polygon.map(clonePoint);
        const xs = polygon.map(pt => pt[0]);
        const ys = polygon.map(pt => pt[1]);
        minX = Math.min(...xs);
        maxX = Math.max(...xs);
        minY = Math.min(...ys);
        maxY = Math.max(...ys);
        widthMm = Math.max(maxX - minX, 1);
        heightMm = Math.max(maxY - minY, 1);
        boardCenter = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
        boardData.polygon = polygon.map(pt => pt.slice());
        boardData.orientation = boardOrientation;
    }

    recalculateBoardGeometry();

    function postToStreamlit(type, payload = {}) {
        if (window.Streamlit) {
            if (type === 'streamlit:setComponentValue' && 'value' in payload) {
                window.Streamlit.setComponentValue(payload.value);
                return;
            }
            if (type === 'streamlit:setFrameHeight' && 'height' in payload) {
                window.Streamlit.setFrameHeight(payload.height);
                return;
            }
            if (type === 'streamlit:componentReady') {
                window.Streamlit.setComponentReady();
                if ('height' in payload) {
                    window.Streamlit.setFrameHeight(payload.height);
                }
                return;
            }
        }
        const message = Object.assign({
            isStreamlitMessage: true,
            type,
        }, payload);
        if (type === 'streamlit:componentReady' && !('apiVersion' in message)) {
            message.apiVersion = 1;
        }
        if (componentId) {
            message.componentId = componentId;
        }
        window.parent.postMessage(message, '*');
    }
    let nextCircleColor = 0;
    let sectionMode = false;
    let activeSectionIds = null;
    const sectionInitialPositions = new Map();
    const MIN_ZOOM = 0.4;
    const MAX_ZOOM = 3;
    zoom = Math.min(Math.max(Number.isFinite(zoom) ? zoom : 1, MIN_ZOOM), MAX_ZOOM);
    pan = { x: 0, y: 0 };

    const canvas = document.getElementById('boardCanvas');
    const ctx = canvas.getContext('2d');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValueLabel = document.getElementById('zoomValue');
    const resetViewButton = document.getElementById('resetView');
    const orientationLabel = document.getElementById('boardOrientationLabel');
    const rotateBoardLeftButton = document.getElementById('boardRotateLeft');
    const rotateBoardRightButton = document.getElementById('boardRotateRight');

    function buildGuideCircleList(source) {
        nextCircleColor = 0;
        return (Array.isArray(source) ? source : []).map((circle, idx) => {
            if (!circle || typeof circle !== 'object') { return null; }
            const radius = typeof circle.radius === 'number' ? circle.radius : 0;
            if (!radius || radius <= 0) { return null; }
            const x = typeof circle.x === 'number' ? circle.x : boardCenter.x;
            const y = typeof circle.y === 'number' ? circle.y : boardCenter.y;
            return {
                id: circle.id || ('circle-' + idx),
                radius,
                x,
                y,
                color: typeof circle.color === 'string' && circle.color ? circle.color : colorPalette[nextCircleColor++ % colorPalette.length],
                label: typeof circle.label === 'string' && circle.label ? circle.label : `Radius ${radius.toFixed(0)} mm`,
            };
        }).filter(Boolean);
    }

    guideCircles = buildGuideCircleList(guideCircles);
    selectedCircleId = guideCircles.length ? guideCircles[guideCircles.length - 1].id : null;
    let draggingCircleId = null;
    let circleDragOffset = { x: 0, y: 0 };
    const SNAP_DISTANCE_MM = 200;
    const CONNECTION_TOLERANCE_MM = 3;
    const ANGLE_TOLERANCE_RAD = Math.PI / 36;

    function getGuideCircleHandleRadiusMm(circle) {
        if (!circle || typeof circle.radius !== 'number') {
            return GUIDE_CIRCLE_HANDLE_MIN_RADIUS_MM;
        }
        const scaledRadius = circle.radius * GUIDE_CIRCLE_HANDLE_RADIUS_RATIO;
        const boundedRadius = Math.min(Math.max(scaledRadius, GUIDE_CIRCLE_HANDLE_MIN_RADIUS_MM), GUIDE_CIRCLE_HANDLE_MAX_RADIUS_MM);
        return boundedRadius;
    }

    function updateBoardOrientationLabel() {
        if (!orientationLabel) { return; }
        const value = ((boardOrientation % 360) + 360) % 360;
        orientationLabel.textContent = `${Math.round(value)}Â°`;
    }

    updateBoardOrientationLabel();

    function toRadians(degrees) {
        return (degrees || 0) * Math.PI / 180;
    }

    function toDegrees(radians) {
        return radians * 180 / Math.PI;
    }

    function normalizeRadians(angle) {
        if (!isFinite(angle)) { return 0; }
        const twoPi = Math.PI * 2;
        let value = angle % twoPi;
        if (value <= -Math.PI) {
            value += twoPi;
        }
        if (value > Math.PI) {
            value -= twoPi;
        }
        return value;
    }

    function normalizeDegrees(angle) {
        if (!isFinite(angle)) { return 0; }
        let value = angle % 360;
        if (value <= -180) {
            value += 360;
        }
        if (value > 180) {
            value -= 360;
        }
        return value;
    }

    function rotatePoint(x, y, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return {
            x: x * cos - y * sin,
            y: x * sin + y * cos,
        };
    }

    function getPlacementById(id) {
        return placements.find(item => item.id === id) || null;
    }

    function computeBaseScale() {
        const availableWidth = Math.max(canvas.width - padding * 2, 1);
        const availableHeight = Math.max(canvas.height - padding * 2, 1);
        return Math.min(availableWidth / widthMm, availableHeight / heightMm);
    }

    function getScale() {
        return computeBaseScale() * zoom;
    }

    function clampPan() {
        const scale = getScale();
        if (!Number.isFinite(scale) || scale <= 0 || !canvas.width || !canvas.height) {
            pan.x = 0;
            pan.y = 0;
            return;
        }
        const boardWidth = Math.max(widthMm * scale, 0);
        const boardHeight = Math.max(heightMm * scale, 0);
        const marginX = Math.min(canvas.width * 0.35, 180);
        const marginY = Math.min(canvas.height * 0.35, 180);
        const minPanX = marginX - padding - boardWidth;
        const maxPanX = canvas.width - marginX - padding;
        if (minPanX <= maxPanX) {
            pan.x = Math.min(Math.max(pan.x, minPanX), maxPanX);
        } else {
            pan.x = (minPanX + maxPanX) / 2;
        }
        const bottomBase = canvas.height - padding;
        const topBase = bottomBase - boardHeight;
        const minPanY = marginY - bottomBase;
        const maxPanY = canvas.height - marginY - topBase;
        if (minPanY <= maxPanY) {
            pan.y = Math.min(Math.max(pan.y, minPanY), maxPanY);
        } else {
            pan.y = (minPanY + maxPanY) / 2;
        }
    }

    function updateZoomUI() {
        if (zoomSlider) {
            zoomSlider.value = zoom.toFixed(2);
        }
        if (zoomValueLabel) {
            zoomValueLabel.textContent = Math.round(zoom * 100) + '%';
        }
    }

    function setZoom(targetZoom, focusPoint) {
        const clamped = Math.min(Math.max(targetZoom, MIN_ZOOM), MAX_ZOOM);
        if (!Number.isFinite(clamped) || Math.abs(clamped - zoom) < 1e-4) {
            zoom = clamped;
            updateZoomUI();
            return;
        }
        const focus = focusPoint || { x: canvas.width / 2, y: canvas.height / 2 };
        const mmBefore = canvasToMm(focus.x, focus.y);
        zoom = clamped;
        const after = mmToCanvas(mmBefore.x, mmBefore.y);
        pan.x += focus.x - after.x;
        pan.y += focus.y - after.y;
        clampPan();
        updateZoomUI();
        draw();
        emitState();
    }

    function resetView() {
        zoom = 1;
        pan = { x: 0, y: 0 };
        clampPan();
        updateZoomUI();
        draw();
        emitState();
    }

    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        clampPan();
        updateZoomUI();
        draw();
        requestFrameHeight();
    }

    function mmToCanvas(x, y) {
        const scale = getScale();
        const cx = (x - minX) * scale + padding + pan.x;
        const cy = canvas.height - ((y - minY) * scale + padding) + pan.y;
        return { x: cx, y: cy, scale };
    }

    function canvasToMm(x, y) {
        const scale = getScale();
        const mmX = (x - padding - pan.x) / scale + minX;
        const mmY = ((canvas.height - (y - pan.y)) - padding) / scale + minY;
        return { x: mmX, y: mmY, scale };
    }

    function drawBoard() {
        if (!polygon.length) {
            return;
        }
        ctx.save();
        ctx.beginPath();
        polygon.forEach((pt, idx) => {
            const { x, y } = mmToCanvas(pt[0], pt[1]);
            if (idx === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.closePath();
        ctx.fillStyle = '#f5f7ff';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#5a6aa1';
        ctx.stroke();
        ctx.restore();
    }

    function drawPlacements() {
        placements.forEach(placement => {
            const piece = libraryByCode[placement.code];
            if (!piece) { return; }
            const { x, y, scale } = mmToCanvas(placement.x, placement.y);
            const rotation = (placement.rotation || 0) * Math.PI / 180;
            const selected = placement.id === selectedId;
            const displayLength = piece.displayLength || piece.length || 0;
            const trackWidth = Math.max(32 * scale, 4);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(-rotation);
            if (piece.kind === 'curve' && piece.radius && piece.angle) {
                const radiusPx = piece.radius * scale;
                const startAngle = piece.angle * Math.PI / 180 / 2;
                ctx.beginPath();
                ctx.strokeStyle = selected ? '#d62728' : '#1f77b4';
                ctx.lineWidth = 6;
                ctx.arc(0, 0, radiusPx, startAngle, -startAngle, true);
                ctx.stroke();
            } else {
                const halfLength = (displayLength / 2) * scale;
                ctx.beginPath();
                ctx.fillStyle = selected ? '#ffe5d1' : '#dce9ff';
                ctx.strokeStyle = selected ? '#d62728' : '#1f77b4';
                ctx.lineWidth = Math.max(2, trackWidth / 8);
                ctx.rect(-halfLength, -trackWidth / 2, halfLength * 2, trackWidth);
                ctx.fill();
                ctx.stroke();
            }
            ctx.restore();

            // Connection points
            const points = connectionPoints(placement);
            points.forEach(pt => {
                const { x: px, y: py } = mmToCanvas(pt.x, pt.y);
                ctx.beginPath();
                ctx.fillStyle = '#2ca02c';
                ctx.arc(px, py, 6, 0, 2 * Math.PI);
                ctx.fill();
            });
        });
    }

    function drawGuideCircles() {
        guideCircles.forEach(circle => {
            const { x, y, scale } = mmToCanvas(circle.x, circle.y);
            const radiusPx = circle.radius * scale;
            const handleColor = circle.color || '#ff7f0e';
            const handleRadiusMm = getGuideCircleHandleRadiusMm(circle);
            const handleRadiusPx = Math.max(handleRadiusMm * scale, 6);
            ctx.save();
            ctx.beginPath();
            ctx.setLineDash([10, 6]);
            ctx.lineWidth = circle.id === selectedCircleId ? 3 : 2;
            ctx.strokeStyle = handleColor;
            ctx.arc(x, y, radiusPx, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 0.16;
            ctx.fillStyle = handleColor;
            ctx.beginPath();
            ctx.arc(x, y, handleRadiusPx, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = handleColor;
            ctx.arc(x, y, handleRadiusPx, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.fillStyle = '#ffffff';
            ctx.arc(x, y, Math.max(handleRadiusPx * 0.45, 2), 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle = handleColor;
            ctx.arc(x, y, Math.max(handleRadiusPx * 0.2, 3), 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard();
        drawPlacements();
    }

    function endpointGeometry(placement) {
        const piece = libraryByCode[placement.code];
        if (!piece) { return []; }
        const rotation = toRadians(placement.rotation || 0);
        const flipped = placement.flipped ? -1 : 1;

        if (piece.kind === 'curve' && piece.radius && piece.angle) {
            const halfTheta = toRadians(piece.angle) / 2;
            const orientation = flipped;
            const baseAngles = [halfTheta, -halfTheta];
            return baseAngles.map(baseAngle => {
                const angleLocal = baseAngle * orientation;
                const localPosition = {
                    x: piece.radius * Math.cos(angleLocal),
                    y: piece.radius * Math.sin(angleLocal),
                };
                const rotated = rotatePoint(localPosition.x, localPosition.y, rotation);
                const tangentVector = {
                    x: -Math.sin(angleLocal) * orientation,
                    y: Math.cos(angleLocal) * orientation,
                };
                const tangentLocalAngle = Math.atan2(tangentVector.y, tangentVector.x);
                const radialLocalAngle = Math.atan2(localPosition.y, localPosition.x);
                return {
                    x: placement.x + rotated.x,
                    y: placement.y + rotated.y,
                    tangent: normalizeRadians(tangentLocalAngle + rotation),
                    radial: normalizeRadians(radialLocalAngle + rotation),
                    radialVector: rotated,
                    localPosition,
                    localTangent: tangentLocalAngle,
                    localRadial: radialLocalAngle,
                };
            });
        }

        const displayLength = piece.displayLength || piece.length || 0;
        const halfLength = displayLength / 2;
        const endpoints = [
            {
                localPosition: { x: halfLength, y: 0 },
                localTangent: 0,
            },
            {
                localPosition: { x: -halfLength, y: 0 },
                localTangent: Math.PI,
            },
        ];
        return endpoints.map(endpoint => {
            const rotated = rotatePoint(endpoint.localPosition.x, endpoint.localPosition.y, rotation);
            const radialLocalAngle = Math.atan2(endpoint.localPosition.y, endpoint.localPosition.x);
            return {
                x: placement.x + rotated.x,
                y: placement.y + rotated.y,
                tangent: normalizeRadians(endpoint.localTangent + rotation),
                radial: normalizeRadians(radialLocalAngle + rotation),
                radialVector: rotated,
                localPosition: endpoint.localPosition,
                localTangent: endpoint.localTangent,
                localRadial: radialLocalAngle,
            };
        });
    }

    function connectionPoints(placement) {
        return endpointGeometry(placement).map(endpoint => ({ x: endpoint.x, y: endpoint.y }));
    }

    function endpointsAreConnected(endpointA, endpointB) {
        const dx = endpointA.x - endpointB.x;
        const dy = endpointA.y - endpointB.y;
        const distance = Math.hypot(dx, dy);
        if (distance > CONNECTION_TOLERANCE_MM) {
            return false;
        }
        const tangentDiff = Math.abs(normalizeRadians(endpointA.tangent - endpointB.tangent));
        const radialA = endpointA.radial;
        const radialB = endpointB.radial;
        const radialDiff =
            radialA === undefined || radialB === undefined
                ? Number.POSITIVE_INFINITY
                : Math.abs(normalizeRadians(radialA - radialB));
        const tangentsOpposed = Math.abs(tangentDiff - Math.PI) < ANGLE_TOLERANCE_RAD;
        const radialsAligned = radialDiff < ANGLE_TOLERANCE_RAD;
        return tangentsOpposed || radialsAligned;
    }

    function connectedSectionIds(originId) {
        const visited = new Set();
        const queue = [originId];
        while (queue.length) {
            const currentId = queue.shift();
            if (!currentId || visited.has(currentId)) {
                continue;
            }
            visited.add(currentId);
            const placement = getPlacementById(currentId);
            if (!placement) { continue; }
            const endpoints = endpointGeometry(placement);
            placements.forEach(other => {
                if (other.id === currentId || visited.has(other.id)) { return; }
                const otherEndpoints = endpointGeometry(other);
                for (let i = 0; i < endpoints.length; i += 1) {
                    for (let j = 0; j < otherEndpoints.length; j += 1) {
                        if (endpointsAreConnected(endpoints[i], otherEndpoints[j])) {
                            queue.push(other.id);
                            return;
                        }
                    }
                }
            });
        }
        return Array.from(visited);
    }

    function applySectionTransform(sectionIds, pivotPoint, deltaRotationDeg, deltaX, deltaY) {
        const rotationRad = toRadians(deltaRotationDeg);
        const cos = Math.cos(rotationRad);
        const sin = Math.sin(rotationRad);
        sectionIds.forEach(id => {
            const piece = getPlacementById(id);
            if (!piece) { return; }
            if (deltaRotationDeg) {
                const relX = piece.x - pivotPoint.x;
                const relY = piece.y - pivotPoint.y;
                const rotatedX = relX * cos - relY * sin;
                const rotatedY = relX * sin + relY * cos;
                piece.x = pivotPoint.x + rotatedX;
                piece.y = pivotPoint.y + rotatedY;
                piece.rotation = (piece.rotation + deltaRotationDeg + 360) % 360;
            }
            piece.x += deltaX;
            piece.y += deltaY;
        });
    }

    function findBestSnapTransform(placement) {
        const endpoints = endpointGeometry(placement);
        let best = null;
        placements.forEach(other => {
            if (other.id === placement.id) { return; }
            const otherEndpoints = endpointGeometry(other);
            endpoints.forEach(endpoint => {
                otherEndpoints.forEach(target => {
                    const dx = endpoint.x - target.x;
                    const dy = endpoint.y - target.y;
                    const distance = Math.hypot(dx, dy);
                    if (distance > SNAP_DISTANCE_MM) { return; }
                    const candidateTangents = [
                        normalizeRadians(target.tangent + Math.PI),
                        normalizeRadians(target.tangent),
                    ];
                    candidateTangents.forEach(desiredTangent => {
                        const deltaRotationRad = normalizeRadians(desiredTangent - endpoint.tangent);
                        const deltaRotationDeg = normalizeDegrees(toDegrees(deltaRotationRad));
                        const newRotationDeg = (placement.rotation + deltaRotationDeg + 360) % 360;
                        const newRotationRad = toRadians(newRotationDeg);
                        const rotatedLocal = rotatePoint(endpoint.localPosition.x, endpoint.localPosition.y, newRotationRad);
                        const newCenterX = target.x - rotatedLocal.x;
                        const newCenterY = target.y - rotatedLocal.y;
                        const transformedEndpoint = {
                            x: target.x,
                            y: target.y,
                            tangent: normalizeRadians(endpoint.localTangent + newRotationRad),
                            radial: normalizeRadians(Math.atan2(rotatedLocal.y, rotatedLocal.x)),
                        };
                        if (!endpointsAreConnected(transformedEndpoint, target)) { return; }
                        const deltaX = newCenterX - placement.x;
                        const deltaY = newCenterY - placement.y;
                        const rotationMagnitude = Math.abs(deltaRotationDeg);
                        if (
                            !best ||
                            distance < best.distance - 1e-6 ||
                            (Math.abs(distance - best.distance) < 1e-6 && rotationMagnitude < best.rotationMagnitude - 1e-6)
                        ) {
                            best = {
                                distance,
                                deltaRotationDeg,
                                deltaX,
                                deltaY,
                                rotationMagnitude,
                            };
                        }
                    });
                });
            });
        });
        if (best) {
            delete best.rotationMagnitude;
        }
        return best;
    }

    function rotateBoard(deltaDegrees) {
        if (!Number.isFinite(deltaDegrees)) { return; }
        const radians = toRadians(deltaDegrees);
        const centre = { x: boardCenter.x, y: boardCenter.y };
        polygon = polygon.map(point => {
            const rotated = rotatePoint(point[0] - centre.x, point[1] - centre.y, radians);
            return [centre.x + rotated.x, centre.y + rotated.y];
        });
        placements.forEach(piece => {
            const rotated = rotatePoint(piece.x - centre.x, piece.y - centre.y, radians);
            piece.x = centre.x + rotated.x;
            piece.y = centre.y + rotated.y;
            piece.rotation = (piece.rotation + deltaDegrees + 360) % 360;
        });
        guideCircles.forEach(circle => {
            const rotated = rotatePoint(circle.x - centre.x, circle.y - centre.y, radians);
            circle.x = centre.x + rotated.x;
            circle.y = centre.y + rotated.y;
        });
        boardOrientation = (boardOrientation + deltaDegrees) % 360;
        recalculateBoardGeometry();
        clampPan();
        draw();
        updateBoardOrientationLabel();
        updateSelectionLabel();
        renderCircleList();
        emitState();
    }

    let emitScheduled = false;
    let lastEmittedJson = null;

    function buildStatePayload() {
        return {
            placements: placements.map(item => ({
                id: item.id,
                code: item.code,
                x: item.x,
                y: item.y,
                rotation: item.rotation,
                flipped: item.flipped,
            })),
            board: {
                description: boardData.description,
                polygon: polygon.map(pt => pt.slice()),
                orientation: boardOrientation,
            },
            zoom,
            pan: {
                x: Number.isFinite(pan.x) ? pan.x : 0,
                y: Number.isFinite(pan.y) ? pan.y : 0,
            },
        };
    }

    function flushStatePayload() {
        const payload = buildStatePayload();
        const jsonValue = JSON.stringify(payload);
        if (jsonValue === lastEmittedJson) {
            return payload;
        }
        lastEmittedJson = jsonValue;
        postToStreamlit("streamlit:setComponentValue", {
            value: jsonValue,
        });
        return payload;
    }

    function emitState(options = {}) {
        const { immediate = false } = options;
        if (immediate) {
            return flushStatePayload();
        }
        if (!emitScheduled) {
            emitScheduled = true;
            requestAnimationFrame(() => {
                emitScheduled = false;
                flushStatePayload();
            });
        }
        return buildStatePayload();
    }

    function getCircleById(id) {
        return guideCircles.find(circle => circle.id === id) || null;
    }

    function currentFrameHeight() {
        const bodyHeight = document.body ? document.body.scrollHeight : 0;
        const docHeight = document.documentElement ? document.documentElement.scrollHeight : 0;
        return Math.max(bodyHeight, docHeight, window.innerHeight || 0);
    }

    function requestFrameHeight() {
        postToStreamlit("streamlit:setFrameHeight", {
            height: currentFrameHeight(),
        });
    }

    function announceReady() {
        postToStreamlit("streamlit:componentReady", {
            height: currentFrameHeight(),
        });
    }

    function addPiece(code) {
        const piece = libraryByCode[code];
        if (!piece) { return; }
        const newPlacement = {
            id: 'placement-' + nextId++,
            code,
            x: boardCenter.x,
            y: boardCenter.y,
            rotation: 0,
            flipped: false,
        };
        placements.push(newPlacement);
        selectedId = newPlacement.id;
        activeSectionIds = null;
        sectionInitialPositions.clear();
        updateSelectionLabel();
        draw();
        emitState();
    }

    function applyBoardPayload(payload, options = {}) {
        if (!payload || typeof payload !== 'object') { return; }
        const { recenter = false, emit = false } = options;
        if (typeof payload.description === 'string') {
            boardData.description = payload.description;
        }
        if (Array.isArray(payload.polygon) && payload.polygon.length) {
            polygon = payload.polygon.map(clonePoint);
        } else if (!polygon.length) {
            polygon = defaultPolygon();
        }
        if (typeof payload.orientation === 'number') {
            boardOrientation = payload.orientation;
        }
        recalculateBoardGeometry();
        if (recenter) {
            pan = { x: 0, y: 0 };
        }
        clampPan();
        draw();
        updateBoardOrientationLabel();
        if (emit) {
            emitState();
        }
    }

    function applyRenderArgs(args) {
        if (!args || typeof args !== 'object') { return; }
        const previousSelectedId = selectedId;
        selectedCircleId = null;
        guideCircles = [];
        if (Array.isArray(args.library)) {
            trackLibrary = args.library;
        }
        libraryByCode = Object.fromEntries(trackLibrary.map(item => [item.code, item]));
        renderLibrarySections();
        if (args.board) {
            applyBoardPayload(args.board);
        } else {
            recalculateBoardGeometry();
        }
        if (Array.isArray(args.placements)) {
            placements = args.placements.map((item, idx) => ({
                id: item.id || ('placement-' + idx),
                code: item.code,
                x: typeof item.x === 'number' ? item.x : 0,
                y: typeof item.y === 'number' ? item.y : 0,
                rotation: typeof item.rotation === 'number' ? item.rotation : 0,
                flipped: Boolean(item.flipped),
            }));
            nextId = placements.length;
        }
        if (typeof args.zoom === 'number') {
            zoom = Math.min(Math.max(args.zoom, MIN_ZOOM), MAX_ZOOM);
            updateZoomUI();
        }
        if (args.pan && typeof args.pan === 'object') {
            const panX = Number(args.pan.x);
            const panY = Number(args.pan.y);
            if (Number.isFinite(panX) && Number.isFinite(panY)) {
                pan.x = panX;
                pan.y = panY;
            }
        }
        let resolvedSelectedId = null;
        if (previousSelectedId && placements.some(item => item.id === previousSelectedId)) {
            resolvedSelectedId = previousSelectedId;
        }
        if (!resolvedSelectedId && placements.length) {
            resolvedSelectedId = placements[placements.length - 1].id;
        }
        selectedId = resolvedSelectedId;
        clampPan();
        draw();
        updateBoardOrientationLabel();
        updateSelectionLabel();
        renderCircleList();
        requestFrameHeight();
    }

    function updateSelectionLabel() {
        const label = document.getElementById('selectionLabel');
        const placement = placements.find(p => p.id === selectedId);
        const circle = getCircleById(selectedCircleId);
        if (placement) {
            const piece = libraryByCode[placement.code];
            label.textContent = placement.code + ' Â· ' + (piece ? piece.name : '');
            return;
        }
        if (circle) {
            label.textContent = circle.label || `Guide circle Â· ${circle.radius.toFixed(0)} mm`;
            return;
        }
        label.textContent = 'No piece selected';
    }

    if (zoomSlider) {
        zoomSlider.addEventListener('input', event => {
            const target = parseFloat(event.target.value);
            if (Number.isFinite(target)) {
                setZoom(target, { x: canvas.width / 2, y: canvas.height / 2 });
            }
        });
    }

    if (resetViewButton) {
        resetViewButton.addEventListener('click', () => {
            resetView();
        });
    }

    if (rotateBoardLeftButton) {
        rotateBoardLeftButton.addEventListener('click', () => rotateBoard(-90));
    }
    if (rotateBoardRightButton) {
        rotateBoardRightButton.addEventListener('click', () => rotateBoard(90));
    }

    let dragging = false;
    let dragOffset = { x: 0, y: 0 };
    let viewPanning = false;
    let panPointerStart = { x: 0, y: 0 };
    let panStart = { x: 0, y: 0 };
    let middleButtonPressed = false;

    canvas.addEventListener('pointerdown', event => {
        if (event.button === 1) {
            middleButtonPressed = true;
        }
        const rect = canvas.getBoundingClientRect();
        const { x, y } = canvasToMm(event.clientX - rect.left, event.clientY - rect.top);

        let foundPlacement = null;
        for (let i = placements.length - 1; i >= 0; i -= 1) {
            if (hitTest(placements[i], x, y)) {
                foundPlacement = placements[i];
                break;
            }
        }

        if (foundPlacement) {
            selectedId = foundPlacement.id;
            selectedCircleId = null;
            dragOffset = { x: x - foundPlacement.x, y: y - foundPlacement.y };
            dragging = true;
            viewPanning = false;
            canvas.setPointerCapture(event.pointerId);
            const sectionIds = sectionMode ? connectedSectionIds(foundPlacement.id) : [foundPlacement.id];
            activeSectionIds = new Set(sectionIds);
            sectionInitialPositions.clear();
            sectionIds.forEach(id => {
                const piece = getPlacementById(id);
                if (piece) {
                    sectionInitialPositions.set(id, { x: piece.x, y: piece.y });
                }
            });
            updateSelectionLabel();
            draw();
            return;
        }

        for (let i = guideCircles.length - 1; i >= 0; i -= 1) {
            const circle = guideCircles[i];
            const distance = Math.hypot(x - circle.x, y - circle.y);
            const handleRadius = getGuideCircleHandleRadiusMm(circle);
            if (distance <= handleRadius) {
                selectedCircleId = circle.id;
                selectedId = null;
                draggingCircleId = circle.id;
                circleDragOffset = { x: x - circle.x, y: y - circle.y };
                canvas.setPointerCapture(event.pointerId);
                updateSelectionLabel();
                renderCircleList();
                draw();
                return;
            }
        }

        selectedId = null;
        selectedCircleId = null;
        activeSectionIds = null;
        sectionInitialPositions.clear();
        viewPanning = false;
        updateSelectionLabel();
        if (event.button === 0) {
            viewPanning = true;
            panPointerStart = { x: event.clientX, y: event.clientY };
            panStart = { x: pan.x, y: pan.y };
            canvas.setPointerCapture(event.pointerId);
            event.preventDefault();
        }
        draw();
    });

    canvas.addEventListener('pointermove', event => {
        if (draggingCircleId) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const { x, y } = canvasToMm(event.clientX - rect.left, event.clientY - rect.top);
            const circle = getCircleById(draggingCircleId);
            if (circle) {
                circle.x = x - circleDragOffset.x;
                circle.y = y - circleDragOffset.y;
                draw();
            }
            return;
        }
        if (viewPanning) {
            event.preventDefault();
            const dx = event.clientX - panPointerStart.x;
            const dy = event.clientY - panPointerStart.y;
            pan.x = panStart.x + dx;
            pan.y = panStart.y + dy;
            clampPan();
            draw();
            return;
        }
        if (!dragging || !selectedId) { return; }
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        const rect = canvas.getBoundingClientRect();
        const { x, y } = canvasToMm(event.clientX - rect.left, event.clientY - rect.top);
        const initial = sectionInitialPositions.get(selectedId) || { x: placement.x, y: placement.y };
        const targetX = x - dragOffset.x;
        const targetY = y - dragOffset.y;
        const deltaX = targetX - initial.x;
        const deltaY = targetY - initial.y;
        const ids = activeSectionIds ? Array.from(activeSectionIds) : [selectedId];
        ids.forEach(id => {
            const piece = getPlacementById(id);
            const start = sectionInitialPositions.get(id);
            if (!piece || !start) { return; }
            piece.x = start.x + deltaX;
            piece.y = start.y + deltaY;
        });
        draw();
    });

    canvas.addEventListener('pointerup', event => {
        if (event.button === 1) {
            middleButtonPressed = false;
        }
        if (canvas.hasPointerCapture(event.pointerId)) {
            canvas.releasePointerCapture(event.pointerId);
        }
        let shouldEmit = false;
        if (dragging) {
            dragging = false;
            activeSectionIds = null;
            sectionInitialPositions.clear();
            shouldEmit = true;
        }
        if (viewPanning) {
            viewPanning = false;
            shouldEmit = true;
        }
        if (draggingCircleId) {
            draggingCircleId = null;
            renderCircleList();
            shouldEmit = true;
        }
        if (shouldEmit) {
            emitState();
        }
    });

    canvas.addEventListener('pointercancel', event => {
        middleButtonPressed = false;
        if (canvas.hasPointerCapture(event.pointerId)) {
            canvas.releasePointerCapture(event.pointerId);
        }
        let shouldEmit = false;
        if (dragging) {
            dragging = false;
            activeSectionIds = null;
            sectionInitialPositions.clear();
            shouldEmit = true;
        }
        if (viewPanning) {
            viewPanning = false;
            shouldEmit = true;
        }
        if (draggingCircleId) {
            draggingCircleId = null;
            renderCircleList();
            shouldEmit = true;
        }
        if (shouldEmit) {
            emitState();
        }
    });

    canvas.addEventListener('wheel', event => {
        const isZooming = event.ctrlKey || event.metaKey;
        const isPanning = !isZooming && (event.shiftKey || middleButtonPressed);
        if (!isZooming && !isPanning) {
            return;
        }
        event.preventDefault();
        if (isZooming) {
            const rect = canvas.getBoundingClientRect();
            const focus = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top,
            };
            const zoomFactor = Math.exp(-event.deltaY * 0.0015);
            setZoom(zoom * zoomFactor, focus);
        } else {
            pan.x -= event.deltaX;
            pan.y -= event.deltaY;
            clampPan();
            draw();
            emitState();
        }
    }, { passive: false });

    function hitTest(placement, x, y) {
        const piece = libraryByCode[placement.code];
        if (!piece) { return false; }
        const rotation = (placement.rotation || 0) * Math.PI / 180;
        const dx = x - placement.x;
        const dy = y - placement.y;
        const cos = Math.cos(rotation);
        const sin = Math.sin(rotation);
        const localX = cos * dx + sin * dy;
        const localY = -sin * dx + cos * dy;
        if (piece.kind === 'curve' && piece.radius) {
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (Math.abs(dist - piece.radius) >= 60) {
                return false;
            }
            if (!piece.angle) {
                return true;
            }
            const pointerAngle = normalizeRadians(Math.atan2(dy, dx) - rotation);
            const orientation = placement.flipped ? -1 : 1;
            const adjustedAngle = normalizeRadians(pointerAngle * orientation);
            const halfSweep = toRadians(piece.angle) / 2;
            return adjustedAngle >= -halfSweep && adjustedAngle <= halfSweep;
        }
        const length = piece.displayLength || piece.length || 0;
        return Math.abs(localX) <= length / 2 && Math.abs(localY) <= 50;
    }

    function adjustSelected(deltaRotation = 0, deltaX = 0, deltaY = 0) {
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        const pivot = { x: placement.x, y: placement.y };
        const sectionIds = sectionMode ? connectedSectionIds(selectedId) : [selectedId];
        applySectionTransform(sectionIds, pivot, deltaRotation, deltaX, deltaY);
        draw();
        emitState();
    }

    document.getElementById('rotateLeft').addEventListener('click', () => adjustSelected(-15, 0, 0));
    document.getElementById('rotateRight').addEventListener('click', () => adjustSelected(15, 0, 0));
    document.getElementById('nudgeUp').addEventListener('click', () => adjustSelected(0, 0, 10));
    document.getElementById('nudgeDown').addEventListener('click', () => adjustSelected(0, 0, -10));
    document.getElementById('nudgeLeft').addEventListener('click', () => adjustSelected(0, -10, 0));
    document.getElementById('nudgeRight').addEventListener('click', () => adjustSelected(0, 10, 0));
    document.getElementById('flipPiece').addEventListener('click', () => {
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        placement.flipped = !placement.flipped;
        draw();
        emitState();
    });

    document.getElementById('snapGrid').addEventListener('click', () => {
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        const targetX = Math.round(placement.x / 10) * 10;
        const targetY = Math.round(placement.y / 10) * 10;
        const targetRotation = Math.round((placement.rotation || 0) / 15) * 15;
        const deltaX = targetX - placement.x;
        const deltaY = targetY - placement.y;
        const deltaRotation = normalizeDegrees(targetRotation - (placement.rotation || 0));
        const pivot = { x: placement.x, y: placement.y };
        const sectionIds = sectionMode ? connectedSectionIds(selectedId) : [selectedId];
        applySectionTransform(sectionIds, pivot, deltaRotation, deltaX, deltaY);
        const updatedPlacement = getPlacementById(selectedId);
        if (updatedPlacement) {
            updatedPlacement.rotation = ((targetRotation % 360) + 360) % 360;
        }
        draw();
        emitState();
    });

    document.getElementById('snapPiece').addEventListener('click', () => {
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        const transform = findBestSnapTransform(placement);
        if (!transform) { return; }
        const pivot = { x: placement.x, y: placement.y };
        const sectionIds = sectionMode ? connectedSectionIds(selectedId) : [selectedId];
        applySectionTransform(sectionIds, pivot, transform.deltaRotationDeg, transform.deltaX, transform.deltaY);
        draw();
        emitState();
    });

    const sectionToggleButton = document.getElementById('toggleSectionMode');

    function updateSectionToggleButton() {
        if (!sectionToggleButton) { return; }
        sectionToggleButton.textContent = sectionMode ? 'Section move: On' : 'Section move: Off';
        sectionToggleButton.classList.toggle('primary', sectionMode);
    }

    if (sectionToggleButton) {
        sectionToggleButton.addEventListener('click', () => {
            sectionMode = !sectionMode;
            if (!sectionMode) {
                activeSectionIds = null;
                sectionInitialPositions.clear();
            }
            updateSectionToggleButton();
        });
    }
    document.getElementById('deletePiece').addEventListener('click', () => {
        if (selectedCircleId) {
            const circleIndex = guideCircles.findIndex(circle => circle.id === selectedCircleId);
            if (circleIndex !== -1) {
                guideCircles.splice(circleIndex, 1);
                selectedCircleId = guideCircles.length ? guideCircles[guideCircles.length - 1].id : null;
                renderCircleList();
                updateSelectionLabel();
                draw();
                emitState();
                return;
            }
        }
        const index = placements.findIndex(p => p.id === selectedId);
        if (index === -1) { return; }
        placements.splice(index, 1);
        selectedId = placements.length ? placements[placements.length - 1].id : null;
        activeSectionIds = null;
        sectionInitialPositions.clear();
        updateSelectionLabel();
        draw();
        emitState();
    });

    function renderCircleList() {
        const list = document.getElementById('circleList');
        if (!list) { return; }
        if (!guideCircles.length) {
            list.innerHTML = '<p class="hint">No planning circles added yet.</p>';
            requestFrameHeight();
            return;
        }
        const entries = guideCircles.map(circle => {
            const selected = circle.id === selectedCircleId ? ' selected' : '';
            const label = circle.label || `Radius ${circle.radius.toFixed(0)} mm`;
            const position = `Centre ${circle.x.toFixed(0)} mm Â· ${circle.y.toFixed(0)} mm`;
            const colour = circle.color || '#ff7f0e';
            return `
                <div class="circle-item${selected}" data-id="${circle.id}">
                    <span class="circle-swatch" style="background:${colour}"></span>
                    <div class="circle-meta">
                        <div><strong>${label}</strong></div>
                        <div>${position}</div>
                    </div>
                    <div class="circle-actions">
                        <button type="button" data-action="remove" data-id="${circle.id}">Remove</button>
                    </div>
                </div>
            `;
        });
        list.innerHTML = entries.join('');
        list.querySelectorAll('.circle-item').forEach(item => {
            item.addEventListener('click', () => {
                const id = item.getAttribute('data-id');
                if (!id) { return; }
                selectedCircleId = id;
                selectedId = null;
                updateSelectionLabel();
                renderCircleList();
                draw();
                emitState();
            });
        });
        list.querySelectorAll('button[data-action="remove"]').forEach(button => {
            button.addEventListener('click', event => {
                event.stopPropagation();
                const id = event.currentTarget.getAttribute('data-id');
                const index = guideCircles.findIndex(circle => circle.id === id);
                if (index !== -1) {
                    guideCircles.splice(index, 1);
                    if (selectedCircleId === id) {
                        selectedCircleId = guideCircles.length ? guideCircles[guideCircles.length - 1].id : null;
                    }
                    renderCircleList();
                    updateSelectionLabel();
                    draw();
                    emitState();
                }
            });
        });
        requestFrameHeight();
    }

    const saveLayoutButton = document.getElementById('saveLayout');
    if (saveLayoutButton) {
        saveLayoutButton.addEventListener('click', () => {
            const payload = emitState({ immediate: true });
            const jsonText = JSON.stringify(payload, null, 2);
            const blob = new Blob([jsonText], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `layout-${timestamp}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        });
    }

    if (window.Streamlit && window.Streamlit.events && window.Streamlit.RENDER_EVENT) {
        window.Streamlit.events.addEventListener(window.Streamlit.RENDER_EVENT, event => {
            const detail = event && event.detail ? event.detail : {};
            applyRenderArgs(detail.args || {});
        });
    } else {
        window.addEventListener('message', event => {
            if (event && event.data && event.data.type === 'streamlit:render') {
                applyRenderArgs(event.data.args || {});
            }
        });
    }

    window.addEventListener('resize', () => {
        resizeCanvas();
        requestFrameHeight();
    });
    resizeCanvas();
    updateSelectionLabel();
    updateSectionToggleButton();
    renderCircleList();
    requestFrameHeight();
    announceReady();
    </script>
    