
    <style>
    :root {
        color-scheme: light;
    }
    html, body {
        min-height: 100vh;
    }
    body {
        margin: 0;
        font-family: 'Source Sans Pro', sans-serif;
        background: linear-gradient(180deg, #eef1f5 0%, #e2e7f0 100%);
        display: flex;
        justify-content: center;
        padding: 1.5rem;
        box-sizing: border-box;
    }
    .designer-wrapper {
        display: grid;
        grid-template-columns: minmax(0, 2.2fr) minmax(280px, 1fr);
        gap: 1.25rem;
        align-items: stretch;
        width: 100%;
        max-width: 1480px;
        flex: 1 1 auto;
        min-height: 0;
        overflow: visible;
    }
    .board-column {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        flex: 1 1 auto;
        min-height: 0;
    }
    .board-canvas {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        flex: 1;
        min-height: 0;
    }
    .board-surface {
        position: relative;
        border: 2px solid #d0d0d0;
        border-radius: 0.5rem;
        background: #ffffff;
        overflow: hidden;
        min-height: 580px;
        height: min(900px, 72vh);
        flex: 1;
        box-shadow: 0 10px 28px rgba(31, 55, 90, 0.12);
    }
    #boardCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
        display: block;
    }
    .view-controls,
    .board-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
    }
    .view-controls label,
    .board-controls span.label {
        font-weight: 600;
        font-size: 0.9rem;
    }
    .view-controls input[type="range"] {
        flex: 1;
        min-width: 160px;
    }
    .view-controls span,
    .board-controls span.value {
        min-width: 3rem;
        text-align: right;
        font-variant-numeric: tabular-nums;
    }
    .view-controls button,
    .board-controls button {
        padding: 0.3rem 0.75rem;
        border-radius: 0.4rem;
        border: 1px solid #666666;
        background: #f8f8f8;
        cursor: pointer;
    }
    .board-controls {
        justify-content: flex-start;
    }
    .board-controls span.value {
        font-weight: 600;
    }
    .piece-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
    }
    .piece-controls button {
        padding: 0.4rem 0.75rem;
        border-radius: 0.4rem;
        border: 1px solid #666666;
        background: #f2f2f2;
        cursor: pointer;
    }
    .piece-controls button.primary {
        border-color: #1f77b4;
        background: #1f77b4;
        color: white;
    }
    .piece-controls span {
        font-weight: 600;
    }
    .hint {
        font-size: 0.85rem;
        color: #555555;
    }
    .export-controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.5rem;
    }
    .export-controls button {
        padding: 0.45rem 0.9rem;
        border-radius: 0.4rem;
        border: 1px solid #1f77b4;
        background: #1f77b4;
        color: #ffffff;
        cursor: pointer;
        font-weight: 600;
    }
    .export-controls .hint {
        margin: 0;
    }
    .library-panel {
        border: 1px solid #d0d0d0;
        border-radius: 0.75rem;
        background: #f8f9fb;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        position: sticky;
        top: 0;
        max-height: 100%;
        overflow: auto;
    }
    .library-panel h3 {
        margin: 0;
        font-size: 1.1rem;
    }
    .library-grid {
        display: grid;
        gap: 0.5rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .library-item {
        border: 1px solid #d7d7d7;
        border-radius: 0.45rem;
        padding: 0.6rem;
        background: #ffffff;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
    }
    .library-heading {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 0.5rem;
    }
    .library-heading span {
        font-size: 0.9rem;
        color: #444444;
    }
    .library-item small {
        color: #666666;
    }
    .library-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
    }
    .library-actions button {
        flex: 1 1 auto;
        padding: 0.35rem 0.5rem;
        border-radius: 0.3rem;
        border: 1px solid #1f77b4;
        background: #1f77b4;
        color: white;
        cursor: pointer;
        font-size: 0.85rem;
    }
    .library-actions button.add-circle {
        border-color: #9467bd;
        background: #9467bd;
    }
    .circle-panel {
        margin-top: 1rem;
        border-top: 1px solid #d0d0d0;
        padding-top: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    .circle-list {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
    }
    .circle-item {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.5rem;
        border: 1px solid #d7d7d7;
        border-radius: 0.45rem;
        padding: 0.4rem 0.6rem;
        background: #ffffff;
    }
    .circle-item.selected {
        border-color: #9467bd;
        box-shadow: 0 0 0 2px rgba(148, 103, 189, 0.25);
    }
    .circle-swatch {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(0, 0, 0, 0.1);
    }
    .circle-meta {
        flex: 1 1 auto;
        min-width: 160px;
        font-size: 0.85rem;
    }
    .circle-actions button {
        padding: 0.3rem 0.6rem;
        border-radius: 0.3rem;
        border: 1px solid #d62728;
        background: #d62728;
        color: white;
        cursor: pointer;
        font-size: 0.8rem;
    }
    @media (max-width: 1100px) {
        body {
            overflow: auto;
            padding: 1rem;
        }
        .designer-wrapper {
            display: flex;
            flex-direction: column;
            height: auto;
        }
        .board-column {
            height: auto;
        }
        .library-panel {
            position: static;
            max-height: none;
        }
    }
    </style>
    <div class="designer-wrapper">
        <div class="board-column">
            <div class="board-canvas">
                <div class="board-surface">
                    <canvas id="boardCanvas"></canvas>
                </div>
                <div class="view-controls">
                    <label for="zoomSlider">Zoom</label>
                    <input type="range" id="zoomSlider" min="0.4" max="3" step="0.01" value="1" />
                    <span id="zoomValue">100%</span>
                    <button id="resetView" type="button">Reset view</button>
                </div>
                <div class="board-controls">
                    <span class="label">Board orientation</span>
                    <button id="boardRotateLeft" type="button">â†º 90Â°</button>
                    <button id="boardRotateRight" type="button">â†» 90Â°</button>
                    <span class="value" id="boardOrientationLabel">0Â°</span>
                </div>
                <div class="piece-controls">
                    <span id="selectionLabel">No piece selected</span>
                    <button id="rotateLeft">âŸ² Rotate -15Â°</button>
                    <button id="rotateRight">âŸ³ Rotate +15Â°</button>
                    <button id="flipPiece">Flip</button>
                    <button id="nudgeUp">â–² Nudge</button>
                    <button id="nudgeDown">â–¼ Nudge</button>
                    <button id="nudgeLeft">â—€ Nudge</button>
                    <button id="nudgeRight">â–¶ Nudge</button>
                    <button id="snapPiece" class="primary">Snap to piece</button>
                    <button id="snapGrid">Snap to 10 mm</button>
                    <button id="toggleSectionMode">Section move: Off</button>
                    <button id="deletePiece">ðŸ—‘ Remove</button>
                </div>
                <p class="hint">Tip: drag pieces directly on the board. Use "Snap to piece" to connect endpoints, or toggle section move to reposition an entire connected run.</p>
                <div class="export-controls">
                    <button id="saveLayout" type="button">ðŸ’¾ Save layout</button>
                    <p class="hint">Download a JSON backup of the current plan.</p>
                </div>
            </div>
        </div>
        <aside class="library-panel">
            <h3>Track library and curve guides</h3>
            <p class="hint">Click "Add to board" to drop a piece. Curved pieces also offer a planning circle that you can drag on the board.</p>
            <div class="library-grid"><div class="library-item"><div class="library-heading"><strong>R600</strong><span>Standard Straight</span></div><small>Straight Â· 168 mm</small><div class="library-actions"><button data-code="R600" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R601</strong><span>Double Straight</span></div><small>Straight Â· 336 mm</small><div class="library-actions"><button data-code="R601" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R602</strong><span>Short Straight</span></div><small>Straight Â· 111 mm</small><div class="library-actions"><button data-code="R602" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R603</strong><span>Half Straight</span></div><small>Straight Â· 67 mm</small><div class="library-actions"><button data-code="R603" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R604</strong><span>Quarter Straight</span></div><small>Straight Â· 41 mm</small><div class="library-actions"><button data-code="R604" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R618</strong><span>Buffer Stop Track</span></div><small>Special Â· 76 mm</small><div class="library-actions"><button data-code="R618" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R627</strong><span>Level Crossing Straight</span></div><small>Special Â· 168 mm</small><div class="library-actions"><button data-code="R627" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R6102</strong><span>Flexi Track (914mm)</span></div><small>Flex Â· 914 mm</small><div class="library-actions"><button data-code="R6102" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R6143</strong><span>Platform Straight</span></div><small>Special Â· 168 mm</small><div class="library-actions"><button data-code="R6143" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R605</strong><span>1st Radius Curve (90Â°)</span></div><small>Curve Â· 583 mm Â· Radius 371 mm</small><div class="library-actions"><button data-code="R605" class="add-piece">Add to board</button><button data-radius="371.0" data-label="R605 (371 mm)" class="add-circle">Add guide circle</button></div></div><div class="library-item"><div class="library-heading"><strong>R606</strong><span>1st Radius Curve (45Â°)</span></div><small>Curve Â· 291 mm Â· Radius 371 mm</small><div class="library-actions"><button data-code="R606" class="add-piece">Add to board</button><button data-radius="371.0" data-label="R606 (371 mm)" class="add-circle">Add guide circle</button></div></div><div class="library-item"><div class="library-heading"><strong>R607</strong><span>2nd Radius Curve (45Â°)</span></div><small>Curve Â· 344 mm Â· Radius 438 mm</small><div class="library-actions"><button data-code="R607" class="add-piece">Add to board</button><button data-radius="438.0" data-label="R607 (438 mm)" class="add-circle">Add guide circle</button></div></div><div class="library-item"><div class="library-heading"><strong>R608</strong><span>3rd Radius Curve (45Â°)</span></div><small>Curve Â· 397 mm Â· Radius 505 mm</small><div class="library-actions"><button data-code="R608" class="add-piece">Add to board</button><button data-radius="505.0" data-label="R608 (505 mm)" class="add-circle">Add guide circle</button></div></div><div class="library-item"><div class="library-heading"><strong>R609</strong><span>4th Radius Curve (45Â°)</span></div><small>Curve Â· 449 mm Â· Radius 572 mm</small><div class="library-actions"><button data-code="R609" class="add-piece">Add to board</button><button data-radius="572.0" data-label="R609 (572 mm)" class="add-circle">Add guide circle</button></div></div><div class="library-item"><div class="library-heading"><strong>R610</strong><span>1st Radius Curve (22.5Â°)</span></div><small>Curve Â· 146 mm Â· Radius 371 mm</small><div class="library-actions"><button data-code="R610" class="add-piece">Add to board</button><button data-radius="371.0" data-label="R610 (371 mm)" class="add-circle">Add guide circle</button></div></div><div class="library-item"><div class="library-heading"><strong>R611</strong><span>2nd Radius Curve (22.5Â°)</span></div><small>Curve Â· 172 mm Â· Radius 438 mm</small><div class="library-actions"><button data-code="R611" class="add-piece">Add to board</button><button data-radius="438.0" data-label="R611 (438 mm)" class="add-circle">Add guide circle</button></div></div><div class="library-item"><div class="library-heading"><strong>R612</strong><span>3rd Radius Curve (22.5Â°)</span></div><small>Curve Â· 198 mm Â· Radius 505 mm</small><div class="library-actions"><button data-code="R612" class="add-piece">Add to board</button><button data-radius="505.0" data-label="R612 (505 mm)" class="add-circle">Add guide circle</button></div></div><div class="library-item"><div class="library-heading"><strong>R613</strong><span>4th Radius Curve (22.5Â°)</span></div><small>Curve Â· 225 mm Â· Radius 572 mm</small><div class="library-actions"><button data-code="R613" class="add-piece">Add to board</button><button data-radius="572.0" data-label="R613 (572 mm)" class="add-circle">Add guide circle</button></div></div><div class="library-item"><div class="library-heading"><strong>R8072</strong><span>Left-hand Point</span></div><small>Point Â· 168 mm</small><div class="library-actions"><button data-code="R8072" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R8073</strong><span>Right-hand Point</span></div><small>Point Â· 168 mm</small><div class="library-actions"><button data-code="R8073" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R8074</strong><span>Y Point</span></div><small>Point Â· 168 mm</small><div class="library-actions"><button data-code="R8074" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R8075</strong><span>Curved Point LH</span></div><small>Point Â· 168 mm Â· Radius 371 mm</small><div class="library-actions"><button data-code="R8075" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R8076</strong><span>Curved Point RH</span></div><small>Point Â· 168 mm Â· Radius 371 mm</small><div class="library-actions"><button data-code="R8076" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R8099</strong><span>Double Slip</span></div><small>Special Â· 168 mm</small><div class="library-actions"><button data-code="R8099" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R614</strong><span>90Â° Crossing</span></div><small>Special Â· 168 mm</small><div class="library-actions"><button data-code="R614" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R615</strong><span>30Â° Crossing</span></div><small>Special Â· 168 mm</small><div class="library-actions"><button data-code="R615" class="add-piece">Add to board</button></div></div><div class="library-item"><div class="library-heading"><strong>R628</strong><span>Diamond Crossing</span></div><small>Special Â· 168 mm</small><div class="library-actions"><button data-code="R628" class="add-piece">Add to board</button></div></div></div>
            <div class="circle-panel">
                <h4>Planning circles</h4>
                <p class="hint">Drag circles on the canvas to position them. Use them to visualise curve radii and loops.</p>
                <div id="circleList" class="circle-list"></div>
            </div>
        </aside>
    </div>
    <script src="https://unpkg.com/streamlit-component-lib/dist/index.js"></script>
    <script>
    let boardData = {"polygon": [[0.0, 0.0], [1800.0, 0.0], [1800.0, 1200.0], [0.0, 1200.0]], "description": "Rectangular board 1.80 m x 1.20 m", "orientation": 0.0};
    let trackLibrary = [{"code": "R600", "name": "Standard Straight", "kind": "straight", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}, {"code": "R601", "name": "Double Straight", "kind": "straight", "length": 335.5, "angle": null, "radius": null, "displayLength": 335.5}, {"code": "R602", "name": "Short Straight", "kind": "straight", "length": 111.0, "angle": null, "radius": null, "displayLength": 111.0}, {"code": "R603", "name": "Half Straight", "kind": "straight", "length": 67.0, "angle": null, "radius": null, "displayLength": 67.0}, {"code": "R604", "name": "Quarter Straight", "kind": "straight", "length": 41.0, "angle": null, "radius": null, "displayLength": 41.0}, {"code": "R618", "name": "Buffer Stop Track", "kind": "special", "length": 76.0, "angle": null, "radius": null, "displayLength": 76.0}, {"code": "R627", "name": "Level Crossing Straight", "kind": "special", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}, {"code": "R6102", "name": "Flexi Track (914mm)", "kind": "flex", "length": 914.0, "angle": null, "radius": null, "displayLength": 914.0}, {"code": "R6143", "name": "Platform Straight", "kind": "special", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}, {"code": "R605", "name": "1st Radius Curve (90\u00b0)", "kind": "curve", "length": 0.0, "angle": 90.0, "radius": 371.0, "displayLength": 582.7654372409066}, {"code": "R606", "name": "1st Radius Curve (45\u00b0)", "kind": "curve", "length": 0.0, "angle": 45.0, "radius": 371.0, "displayLength": 291.3827186204533}, {"code": "R607", "name": "2nd Radius Curve (45\u00b0)", "kind": "curve", "length": 0.0, "angle": 45.0, "radius": 438.0, "displayLength": 344.0043955680824}, {"code": "R608", "name": "3rd Radius Curve (45\u00b0)", "kind": "curve", "length": 0.0, "angle": 45.0, "radius": 505.0, "displayLength": 396.62607251571137}, {"code": "R609", "name": "4th Radius Curve (45\u00b0)", "kind": "curve", "length": 0.0, "angle": 45.0, "radius": 572.0, "displayLength": 449.2477494633404}, {"code": "R610", "name": "1st Radius Curve (22.5\u00b0)", "kind": "curve", "length": 0.0, "angle": 22.5, "radius": 371.0, "displayLength": 145.69135931022666}, {"code": "R611", "name": "2nd Radius Curve (22.5\u00b0)", "kind": "curve", "length": 0.0, "angle": 22.5, "radius": 438.0, "displayLength": 172.0021977840412}, {"code": "R612", "name": "3rd Radius Curve (22.5\u00b0)", "kind": "curve", "length": 0.0, "angle": 22.5, "radius": 505.0, "displayLength": 198.31303625785569}, {"code": "R613", "name": "4th Radius Curve (22.5\u00b0)", "kind": "curve", "length": 0.0, "angle": 22.5, "radius": 572.0, "displayLength": 224.6238747316702}, {"code": "R8072", "name": "Left-hand Point", "kind": "point", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}, {"code": "R8073", "name": "Right-hand Point", "kind": "point", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}, {"code": "R8074", "name": "Y Point", "kind": "point", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}, {"code": "R8075", "name": "Curved Point LH", "kind": "point", "length": 168.0, "angle": 22.5, "radius": 371.0, "displayLength": 168.0}, {"code": "R8076", "name": "Curved Point RH", "kind": "point", "length": 168.0, "angle": 22.5, "radius": 371.0, "displayLength": 168.0}, {"code": "R8099", "name": "Double Slip", "kind": "special", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}, {"code": "R614", "name": "90\u00b0 Crossing", "kind": "special", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}, {"code": "R615", "name": "30\u00b0 Crossing", "kind": "special", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}, {"code": "R628", "name": "Diamond Crossing", "kind": "special", "length": 168.0, "angle": null, "radius": null, "displayLength": 168.0}];
    const initialPlacements = [];
    const initialCircles = [];
    const initialZoom = 1.0;
    const colorPalette = ['#ff7f0e', '#9467bd', '#2ca02c', '#d62728', '#17becf', '#1f77b4'];
    const queryParams = new URLSearchParams(window.location.search);
    const componentId = queryParams.get('componentId');

    let libraryByCode = Object.fromEntries(trackLibrary.map(item => [item.code, item]));
    let placements = initialPlacements.map((item, idx) => ({
        id: item.id || ('placement-' + idx),
        code: item.code,
        x: typeof item.x === 'number' ? item.x : 0,
        y: typeof item.y === 'number' ? item.y : 0,
        rotation: typeof item.rotation === 'number' ? item.rotation : 0,
        flipped: Boolean(item.flipped),
    }));
    let nextId = placements.length;
    let selectedId = placements.length ? placements[placements.length - 1].id : null;

    let boardOrientation = typeof boardData.orientation === 'number' ? boardData.orientation : 0;
    const padding = 60;

    function clonePoint(point) {
        if (Array.isArray(point) && point.length >= 2) {
            const x = Number(point[0]);
            const y = Number(point[1]);
            return [Number.isFinite(x) ? x : 0, Number.isFinite(y) ? y : 0];
        }
        if (point && typeof point === 'object') {
            const x = Number(point.x);
            const y = Number(point.y);
            return [Number.isFinite(x) ? x : 0, Number.isFinite(y) ? y : 0];
        }
        return [0, 0];
    }

    function defaultPolygon() {
        return [[0, 0], [2400, 0], [2400, 1200], [0, 1200]];
    }

    let polygon = (boardData.polygon && boardData.polygon.length ? boardData.polygon : defaultPolygon()).map(clonePoint);
    let minX = 0;
    let maxX = 0;
    let minY = 0;
    let maxY = 0;
    let widthMm = 1;
    let heightMm = 1;
    let boardCenter = { x: 0, y: 0 };

    function recalculateBoardGeometry() {
        if (!polygon.length) {
            polygon = defaultPolygon();
        }
        polygon = polygon.map(clonePoint);
        const xs = polygon.map(pt => pt[0]);
        const ys = polygon.map(pt => pt[1]);
        minX = Math.min(...xs);
        maxX = Math.max(...xs);
        minY = Math.min(...ys);
        maxY = Math.max(...ys);
        widthMm = Math.max(maxX - minX, 1);
        heightMm = Math.max(maxY - minY, 1);
        boardCenter = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
        boardData.polygon = polygon.map(pt => pt.slice());
        boardData.orientation = boardOrientation;
    }

    recalculateBoardGeometry();

    function postToStreamlit(type, payload = {}) {
        if (window.Streamlit) {
            if (type === 'streamlit:setComponentValue' && 'value' in payload) {
                window.Streamlit.setComponentValue(payload.value);
                return;
            }
            if (type === 'streamlit:setFrameHeight' && 'height' in payload) {
                window.Streamlit.setFrameHeight(payload.height);
                return;
            }
            if (type === 'streamlit:componentReady') {
                window.Streamlit.setComponentReady();
                if ('height' in payload) {
                    window.Streamlit.setFrameHeight(payload.height);
                }
                return;
            }
        }
        const message = Object.assign({
            isStreamlitMessage: true,
            type,
        }, payload);
        if (type === 'streamlit:componentReady' && !('apiVersion' in message)) {
            message.apiVersion = 1;
        }
        if (componentId) {
            message.componentId = componentId;
        }
        window.parent.postMessage(message, '*');
    }
    let nextCircleColor = 0;
    let sectionMode = false;
    let activeSectionIds = null;
    const sectionInitialPositions = new Map();
    const MIN_ZOOM = 0.4;
    const MAX_ZOOM = 3;
    let zoom = Number.isFinite(initialZoom) ? Math.min(Math.max(initialZoom, MIN_ZOOM), MAX_ZOOM) : 1;
    let pan = { x: 0, y: 0 };

    const canvas = document.getElementById('boardCanvas');
    const ctx = canvas.getContext('2d');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValueLabel = document.getElementById('zoomValue');
    const resetViewButton = document.getElementById('resetView');
    const orientationLabel = document.getElementById('boardOrientationLabel');
    const rotateBoardLeftButton = document.getElementById('boardRotateLeft');
    const rotateBoardRightButton = document.getElementById('boardRotateRight');

    function buildGuideCircleList(source) {
        nextCircleColor = 0;
        return (Array.isArray(source) ? source : []).map((circle, idx) => {
            if (!circle || typeof circle !== 'object') { return null; }
            const radius = typeof circle.radius === 'number' ? circle.radius : 0;
            if (!radius || radius <= 0) { return null; }
            const x = typeof circle.x === 'number' ? circle.x : boardCenter.x;
            const y = typeof circle.y === 'number' ? circle.y : boardCenter.y;
            return {
                id: circle.id || ('circle-' + idx),
                radius,
                x,
                y,
                color: typeof circle.color === 'string' && circle.color ? circle.color : colorPalette[nextCircleColor++ % colorPalette.length],
                label: typeof circle.label === 'string' && circle.label ? circle.label : `Radius ${radius.toFixed(0)} mm`,
            };
        }).filter(Boolean);
    }

    let guideCircles = buildGuideCircleList(initialCircles);
    let circleCounter = guideCircles.length;
    let selectedCircleId = guideCircles.length ? guideCircles[guideCircles.length - 1].id : null;
    let draggingCircleId = null;
    let circleDragOffset = { x: 0, y: 0 };
    const SNAP_DISTANCE_MM = 200;
    const CONNECTION_TOLERANCE_MM = 3;
    const ANGLE_TOLERANCE_RAD = Math.PI / 36;

    function updateBoardOrientationLabel() {
        if (!orientationLabel) { return; }
        const value = ((boardOrientation % 360) + 360) % 360;
        orientationLabel.textContent = `${Math.round(value)}Â°`;
    }

    updateBoardOrientationLabel();

    function toRadians(degrees) {
        return (degrees || 0) * Math.PI / 180;
    }

    function toDegrees(radians) {
        return radians * 180 / Math.PI;
    }

    function normalizeRadians(angle) {
        if (!isFinite(angle)) { return 0; }
        const twoPi = Math.PI * 2;
        let value = angle % twoPi;
        if (value <= -Math.PI) {
            value += twoPi;
        }
        if (value > Math.PI) {
            value -= twoPi;
        }
        return value;
    }

    function normalizeDegrees(angle) {
        if (!isFinite(angle)) { return 0; }
        let value = angle % 360;
        if (value <= -180) {
            value += 360;
        }
        if (value > 180) {
            value -= 360;
        }
        return value;
    }

    function rotatePoint(x, y, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return {
            x: x * cos - y * sin,
            y: x * sin + y * cos,
        };
    }

    function getPlacementById(id) {
        return placements.find(item => item.id === id) || null;
    }

    function computeBaseScale() {
        const availableWidth = Math.max(canvas.width - padding * 2, 1);
        const availableHeight = Math.max(canvas.height - padding * 2, 1);
        return Math.min(availableWidth / widthMm, availableHeight / heightMm);
    }

    function getScale() {
        return computeBaseScale() * zoom;
    }

    function clampPan() {
        const scale = getScale();
        const contentWidth = widthMm * scale + padding * 2;
        const contentHeight = heightMm * scale + padding * 2;
        const maxPanX = Math.max(contentWidth, canvas.width);
        const maxPanY = Math.max(contentHeight, canvas.height);
        pan.x = Math.min(Math.max(pan.x, -maxPanX), maxPanX);
        pan.y = Math.min(Math.max(pan.y, -maxPanY), maxPanY);
    }

    function updateZoomUI() {
        if (zoomSlider) {
            zoomSlider.value = zoom.toFixed(2);
        }
        if (zoomValueLabel) {
            zoomValueLabel.textContent = Math.round(zoom * 100) + '%';
        }
    }

    function setZoom(targetZoom, focusPoint) {
        const clamped = Math.min(Math.max(targetZoom, MIN_ZOOM), MAX_ZOOM);
        if (!Number.isFinite(clamped) || Math.abs(clamped - zoom) < 1e-4) {
            zoom = clamped;
            updateZoomUI();
            return;
        }
        const focus = focusPoint || { x: canvas.width / 2, y: canvas.height / 2 };
        const mmBefore = canvasToMm(focus.x, focus.y);
        zoom = clamped;
        const after = mmToCanvas(mmBefore.x, mmBefore.y);
        pan.x += focus.x - after.x;
        pan.y += focus.y - after.y;
        clampPan();
        updateZoomUI();
        draw();
        emitState();
    }

    function resetView() {
        zoom = 1;
        pan = { x: 0, y: 0 };
        clampPan();
        updateZoomUI();
        draw();
        emitState();
    }

    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        clampPan();
        updateZoomUI();
        draw();
        requestFrameHeight();
    }

    function mmToCanvas(x, y) {
        const scale = getScale();
        const cx = (x - minX) * scale + padding + pan.x;
        const cy = canvas.height - ((y - minY) * scale + padding) + pan.y;
        return { x: cx, y: cy, scale };
    }

    function canvasToMm(x, y) {
        const scale = getScale();
        const mmX = (x - padding - pan.x) / scale + minX;
        const mmY = ((canvas.height - (y - pan.y)) - padding) / scale + minY;
        return { x: mmX, y: mmY, scale };
    }

    function drawBoard() {
        if (!polygon.length) {
            return;
        }
        ctx.save();
        ctx.beginPath();
        polygon.forEach((pt, idx) => {
            const { x, y } = mmToCanvas(pt[0], pt[1]);
            if (idx === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.closePath();
        ctx.fillStyle = '#f5f7ff';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#5a6aa1';
        ctx.stroke();
        ctx.restore();
    }

    function drawPlacements() {
        placements.forEach(placement => {
            const piece = libraryByCode[placement.code];
            if (!piece) { return; }
            const { x, y, scale } = mmToCanvas(placement.x, placement.y);
            const rotation = (placement.rotation || 0) * Math.PI / 180;
            const selected = placement.id === selectedId;
            const displayLength = piece.displayLength || piece.length || 0;
            const trackWidth = 32 * scale;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(-rotation);
            if (piece.kind === 'curve' && piece.radius && piece.angle) {
                const radiusPx = piece.radius * scale;
                const startAngle = piece.angle * Math.PI / 180 / 2;
                ctx.beginPath();
                ctx.strokeStyle = selected ? '#d62728' : '#1f77b4';
                ctx.lineWidth = 6;
                ctx.arc(0, 0, radiusPx, startAngle, -startAngle, true);
                ctx.stroke();
            } else {
                const halfLength = (displayLength / 2) * scale;
                ctx.beginPath();
                ctx.fillStyle = selected ? '#ffe5d1' : '#dce9ff';
                ctx.strokeStyle = selected ? '#d62728' : '#1f77b4';
                ctx.lineWidth = 2;
                ctx.rect(-halfLength, -trackWidth / 2, halfLength * 2, trackWidth);
                ctx.fill();
                ctx.stroke();
            }
            ctx.restore();

            // Connection points
            const points = connectionPoints(placement);
            points.forEach(pt => {
                const { x: px, y: py } = mmToCanvas(pt.x, pt.y);
                ctx.beginPath();
                ctx.fillStyle = '#2ca02c';
                ctx.arc(px, py, 6, 0, 2 * Math.PI);
                ctx.fill();
            });
        });
    }

    function drawGuideCircles() {
        guideCircles.forEach(circle => {
            const { x, y, scale } = mmToCanvas(circle.x, circle.y);
            const radiusPx = circle.radius * scale;
            ctx.save();
            ctx.beginPath();
            ctx.setLineDash([10, 6]);
            ctx.lineWidth = circle.id === selectedCircleId ? 3 : 2;
            ctx.strokeStyle = circle.color || '#ff7f0e';
            ctx.arc(x, y, radiusPx, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = circle.color || '#ff7f0e';
            ctx.globalAlpha = 0.12;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard();
        drawGuideCircles();
        drawPlacements();
    }

    function endpointGeometry(placement) {
        const piece = libraryByCode[placement.code];
        if (!piece) { return []; }
        const rotation = toRadians(placement.rotation || 0);
        const flipped = placement.flipped ? -1 : 1;

        if (piece.kind === 'curve' && piece.radius && piece.angle) {
            const halfTheta = toRadians(piece.angle) / 2;
            const orientation = flipped;
            const baseAngles = [halfTheta, -halfTheta];
            return baseAngles.map(baseAngle => {
                const angleLocal = baseAngle * orientation;
                const localPosition = {
                    x: piece.radius * Math.cos(angleLocal),
                    y: piece.radius * Math.sin(angleLocal),
                };
                const rotated = rotatePoint(localPosition.x, localPosition.y, rotation);
                const tangentVector = {
                    x: -Math.sin(angleLocal) * orientation,
                    y: Math.cos(angleLocal) * orientation,
                };
                const tangentLocalAngle = Math.atan2(tangentVector.y, tangentVector.x);
                const radialLocalAngle = Math.atan2(localPosition.y, localPosition.x);
                return {
                    x: placement.x + rotated.x,
                    y: placement.y + rotated.y,
                    tangent: normalizeRadians(tangentLocalAngle + rotation),
                    radial: normalizeRadians(radialLocalAngle + rotation),
                    radialVector: rotated,
                    localPosition,
                    localTangent: tangentLocalAngle,
                    localRadial: radialLocalAngle,
                };
            });
        }

        const displayLength = piece.displayLength || piece.length || 0;
        const halfLength = displayLength / 2;
        const endpoints = [
            {
                localPosition: { x: halfLength, y: 0 },
                localTangent: 0,
            },
            {
                localPosition: { x: -halfLength, y: 0 },
                localTangent: Math.PI,
            },
        ];
        return endpoints.map(endpoint => {
            const rotated = rotatePoint(endpoint.localPosition.x, endpoint.localPosition.y, rotation);
            const radialLocalAngle = Math.atan2(endpoint.localPosition.y, endpoint.localPosition.x);
            return {
                x: placement.x + rotated.x,
                y: placement.y + rotated.y,
                tangent: normalizeRadians(endpoint.localTangent + rotation),
                radial: normalizeRadians(radialLocalAngle + rotation),
                radialVector: rotated,
                localPosition: endpoint.localPosition,
                localTangent: endpoint.localTangent,
                localRadial: radialLocalAngle,
            };
        });
    }

    function connectionPoints(placement) {
        return endpointGeometry(placement).map(endpoint => ({ x: endpoint.x, y: endpoint.y }));
    }

    function endpointsAreConnected(endpointA, endpointB) {
        const dx = endpointA.x - endpointB.x;
        const dy = endpointA.y - endpointB.y;
        const distance = Math.hypot(dx, dy);
        if (distance > CONNECTION_TOLERANCE_MM) {
            return false;
        }
        const tangentDiff = Math.abs(normalizeRadians(endpointA.tangent - endpointB.tangent));
        const radialA = endpointA.radial;
        const radialB = endpointB.radial;
        const radialDiff =
            radialA === undefined || radialB === undefined
                ? Number.POSITIVE_INFINITY
                : Math.abs(normalizeRadians(radialA - radialB));
        const tangentsOpposed = Math.abs(tangentDiff - Math.PI) < ANGLE_TOLERANCE_RAD;
        const radialsAligned = radialDiff < ANGLE_TOLERANCE_RAD;
        return tangentsOpposed || radialsAligned;
    }

    function connectedSectionIds(originId) {
        const visited = new Set();
        const queue = [originId];
        while (queue.length) {
            const currentId = queue.shift();
            if (!currentId || visited.has(currentId)) {
                continue;
            }
            visited.add(currentId);
            const placement = getPlacementById(currentId);
            if (!placement) { continue; }
            const endpoints = endpointGeometry(placement);
            placements.forEach(other => {
                if (other.id === currentId || visited.has(other.id)) { return; }
                const otherEndpoints = endpointGeometry(other);
                for (let i = 0; i < endpoints.length; i += 1) {
                    for (let j = 0; j < otherEndpoints.length; j += 1) {
                        if (endpointsAreConnected(endpoints[i], otherEndpoints[j])) {
                            queue.push(other.id);
                            return;
                        }
                    }
                }
            });
        }
        return Array.from(visited);
    }

    function applySectionTransform(sectionIds, pivotPoint, deltaRotationDeg, deltaX, deltaY) {
        const rotationRad = toRadians(deltaRotationDeg);
        const cos = Math.cos(rotationRad);
        const sin = Math.sin(rotationRad);
        sectionIds.forEach(id => {
            const piece = getPlacementById(id);
            if (!piece) { return; }
            if (deltaRotationDeg) {
                const relX = piece.x - pivotPoint.x;
                const relY = piece.y - pivotPoint.y;
                const rotatedX = relX * cos - relY * sin;
                const rotatedY = relX * sin + relY * cos;
                piece.x = pivotPoint.x + rotatedX;
                piece.y = pivotPoint.y + rotatedY;
                piece.rotation = (piece.rotation + deltaRotationDeg + 360) % 360;
            }
            piece.x += deltaX;
            piece.y += deltaY;
        });
    }

    function findBestSnapTransform(placement) {
        const endpoints = endpointGeometry(placement);
        let best = null;
        placements.forEach(other => {
            if (other.id === placement.id) { return; }
            const otherEndpoints = endpointGeometry(other);
            endpoints.forEach(endpoint => {
                otherEndpoints.forEach(target => {
                    const dx = endpoint.x - target.x;
                    const dy = endpoint.y - target.y;
                    const distance = Math.hypot(dx, dy);
                    if (distance > SNAP_DISTANCE_MM) { return; }
                    const candidateTangents = [
                        normalizeRadians(target.tangent + Math.PI),
                        normalizeRadians(target.tangent),
                    ];
                    candidateTangents.forEach(desiredTangent => {
                        const deltaRotationRad = normalizeRadians(desiredTangent - endpoint.tangent);
                        const deltaRotationDeg = normalizeDegrees(toDegrees(deltaRotationRad));
                        const newRotationDeg = (placement.rotation + deltaRotationDeg + 360) % 360;
                        const newRotationRad = toRadians(newRotationDeg);
                        const rotatedLocal = rotatePoint(endpoint.localPosition.x, endpoint.localPosition.y, newRotationRad);
                        const newCenterX = target.x - rotatedLocal.x;
                        const newCenterY = target.y - rotatedLocal.y;
                        const transformedEndpoint = {
                            x: target.x,
                            y: target.y,
                            tangent: normalizeRadians(endpoint.localTangent + newRotationRad),
                            radial: normalizeRadians(Math.atan2(rotatedLocal.y, rotatedLocal.x)),
                        };
                        if (!endpointsAreConnected(transformedEndpoint, target)) { return; }
                        const deltaX = newCenterX - placement.x;
                        const deltaY = newCenterY - placement.y;
                        const rotationMagnitude = Math.abs(deltaRotationDeg);
                        if (
                            !best ||
                            distance < best.distance - 1e-6 ||
                            (Math.abs(distance - best.distance) < 1e-6 && rotationMagnitude < best.rotationMagnitude - 1e-6)
                        ) {
                            best = {
                                distance,
                                deltaRotationDeg,
                                deltaX,
                                deltaY,
                                rotationMagnitude,
                            };
                        }
                    });
                });
            });
        });
        if (best) {
            delete best.rotationMagnitude;
        }
        return best;
    }

    function rotateBoard(deltaDegrees) {
        if (!Number.isFinite(deltaDegrees)) { return; }
        const radians = toRadians(deltaDegrees);
        const centre = { x: boardCenter.x, y: boardCenter.y };
        polygon = polygon.map(point => {
            const rotated = rotatePoint(point[0] - centre.x, point[1] - centre.y, radians);
            return [centre.x + rotated.x, centre.y + rotated.y];
        });
        placements.forEach(piece => {
            const rotated = rotatePoint(piece.x - centre.x, piece.y - centre.y, radians);
            piece.x = centre.x + rotated.x;
            piece.y = centre.y + rotated.y;
            piece.rotation = (piece.rotation + deltaDegrees + 360) % 360;
        });
        guideCircles.forEach(circle => {
            const rotated = rotatePoint(circle.x - centre.x, circle.y - centre.y, radians);
            circle.x = centre.x + rotated.x;
            circle.y = centre.y + rotated.y;
        });
        boardOrientation = (boardOrientation + deltaDegrees) % 360;
        recalculateBoardGeometry();
        clampPan();
        draw();
        updateBoardOrientationLabel();
        updateSelectionLabel();
        renderCircleList();
        emitState();
    }

    function emitState() {
        const payload = {
            placements: placements.map(item => ({
                id: item.id,
                code: item.code,
                x: item.x,
                y: item.y,
                rotation: item.rotation,
                flipped: item.flipped,
            })),
            circles: guideCircles.map(circle => ({
                id: circle.id,
                radius: circle.radius,
                x: circle.x,
                y: circle.y,
                color: circle.color,
                label: circle.label,
            })),
            board: {
                description: boardData.description,
                polygon: polygon.map(pt => pt.slice()),
                orientation: boardOrientation,
            },
            zoom,
        };
        postToStreamlit("streamlit:setComponentValue", {
            value: JSON.stringify(payload),
        });
        return payload;
    }

    function getCircleById(id) {
        return guideCircles.find(circle => circle.id === id) || null;
    }

    function nextCircleColour() {
        const colour = colorPalette[nextCircleColor % colorPalette.length];
        nextCircleColor += 1;
        return colour;
    }

    function currentFrameHeight() {
        const bodyHeight = document.body ? document.body.scrollHeight : 0;
        const docHeight = document.documentElement ? document.documentElement.scrollHeight : 0;
        return Math.max(bodyHeight, docHeight, window.innerHeight || 0);
    }

    function requestFrameHeight() {
        postToStreamlit("streamlit:setFrameHeight", {
            height: currentFrameHeight(),
        });
    }

    function announceReady() {
        postToStreamlit("streamlit:componentReady", {
            height: currentFrameHeight(),
        });
    }

    function addPiece(code) {
        const piece = libraryByCode[code];
        if (!piece) { return; }
        const newPlacement = {
            id: 'placement-' + nextId++,
            code,
            x: boardCenter.x,
            y: boardCenter.y,
            rotation: 0,
            flipped: false,
        };
        placements.push(newPlacement);
        selectedId = newPlacement.id;
        activeSectionIds = null;
        sectionInitialPositions.clear();
        updateSelectionLabel();
        draw();
        emitState();
    }

    function applyBoardPayload(payload, options = {}) {
        if (!payload || typeof payload !== 'object') { return; }
        const { recenter = false, emit = false } = options;
        if (typeof payload.description === 'string') {
            boardData.description = payload.description;
        }
        if (Array.isArray(payload.polygon) && payload.polygon.length) {
            polygon = payload.polygon.map(clonePoint);
        } else if (!polygon.length) {
            polygon = defaultPolygon();
        }
        if (typeof payload.orientation === 'number') {
            boardOrientation = payload.orientation;
        }
        recalculateBoardGeometry();
        if (recenter) {
            pan = { x: 0, y: 0 };
        }
        clampPan();
        draw();
        updateBoardOrientationLabel();
        if (emit) {
            emitState();
        }
    }

    function applyRenderArgs(args) {
        if (!args || typeof args !== 'object') { return; }
        if (Array.isArray(args.library)) {
            trackLibrary = args.library;
            libraryByCode = Object.fromEntries(trackLibrary.map(item => [item.code, item]));
        }
        if (args.board) {
            applyBoardPayload(args.board);
        } else {
            recalculateBoardGeometry();
        }
        if (Array.isArray(args.placements)) {
            placements = args.placements.map((item, idx) => ({
                id: item.id || ('placement-' + idx),
                code: item.code,
                x: typeof item.x === 'number' ? item.x : 0,
                y: typeof item.y === 'number' ? item.y : 0,
                rotation: typeof item.rotation === 'number' ? item.rotation : 0,
                flipped: Boolean(item.flipped),
            }));
            nextId = placements.length;
        }
        if (Array.isArray(args.circles)) {
            guideCircles = buildGuideCircleList(args.circles);
            circleCounter = guideCircles.length;
            selectedCircleId = guideCircles.length ? guideCircles[guideCircles.length - 1].id : null;
        }
        if (typeof args.zoom === 'number') {
            zoom = Math.min(Math.max(args.zoom, MIN_ZOOM), MAX_ZOOM);
            updateZoomUI();
        }
        selectedId = placements.length ? placements[placements.length - 1].id : null;
        clampPan();
        draw();
        updateBoardOrientationLabel();
        updateSelectionLabel();
        renderCircleList();
        requestFrameHeight();
    }

    function updateSelectionLabel() {
        const label = document.getElementById('selectionLabel');
        const placement = placements.find(p => p.id === selectedId);
        const circle = getCircleById(selectedCircleId);
        if (placement) {
            const piece = libraryByCode[placement.code];
            label.textContent = placement.code + ' Â· ' + (piece ? piece.name : '');
            return;
        }
        if (circle) {
            label.textContent = circle.label || `Guide circle Â· ${circle.radius.toFixed(0)} mm`;
            return;
        }
        label.textContent = 'No piece selected';
    }

    document.querySelectorAll('.add-piece').forEach(button => {
        button.addEventListener('click', event => {
            const code = event.currentTarget.getAttribute('data-code');
            addPiece(code);
        });
    });

    document.querySelectorAll('.add-circle').forEach(button => {
        button.addEventListener('click', event => {
            const radius = parseFloat(event.currentTarget.getAttribute('data-radius'));
            if (!Number.isFinite(radius) || radius <= 0) { return; }
            const label = event.currentTarget.getAttribute('data-label') || `Radius ${radius.toFixed(0)} mm`;
            const newCircle = {
                id: 'circle-' + (circleCounter++),
                radius,
                x: boardCenter.x,
                y: boardCenter.y,
                color: nextCircleColour(),
                label,
            };
            guideCircles.push(newCircle);
            selectedCircleId = newCircle.id;
            selectedId = null;
            updateSelectionLabel();
            renderCircleList();
            draw();
            emitState();
        });
    });

    if (zoomSlider) {
        zoomSlider.addEventListener('input', event => {
            const target = parseFloat(event.target.value);
            if (Number.isFinite(target)) {
                setZoom(target, { x: canvas.width / 2, y: canvas.height / 2 });
            }
        });
    }

    if (resetViewButton) {
        resetViewButton.addEventListener('click', () => {
            resetView();
        });
    }

    if (rotateBoardLeftButton) {
        rotateBoardLeftButton.addEventListener('click', () => rotateBoard(-90));
    }
    if (rotateBoardRightButton) {
        rotateBoardRightButton.addEventListener('click', () => rotateBoard(90));
    }

    let dragging = false;
    let dragOffset = { x: 0, y: 0 };
    let viewPanning = false;
    let panPointerStart = { x: 0, y: 0 };
    let panStart = { x: 0, y: 0 };

    canvas.addEventListener('pointerdown', event => {
        const rect = canvas.getBoundingClientRect();
        const { x, y } = canvasToMm(event.clientX - rect.left, event.clientY - rect.top);
        for (let i = guideCircles.length - 1; i >= 0; i -= 1) {
            const circle = guideCircles[i];
            const distance = Math.hypot(x - circle.x, y - circle.y);
            if (distance <= circle.radius) {
                selectedCircleId = circle.id;
                selectedId = null;
                draggingCircleId = circle.id;
                circleDragOffset = { x: x - circle.x, y: y - circle.y };
                canvas.setPointerCapture(event.pointerId);
                updateSelectionLabel();
                renderCircleList();
                draw();
                return;
            }
        }
        let found = null;
        for (let i = placements.length - 1; i >= 0; i -= 1) {
            if (hitTest(placements[i], x, y)) {
                found = placements[i];
                break;
            }
        }
        if (found) {
            selectedId = found.id;
            selectedCircleId = null;
            dragOffset = { x: x - found.x, y: y - found.y };
            dragging = true;
            viewPanning = false;
            canvas.setPointerCapture(event.pointerId);
            const sectionIds = sectionMode ? connectedSectionIds(found.id) : [found.id];
            activeSectionIds = new Set(sectionIds);
            sectionInitialPositions.clear();
            sectionIds.forEach(id => {
                const piece = getPlacementById(id);
                if (piece) {
                    sectionInitialPositions.set(id, { x: piece.x, y: piece.y });
                }
            });
            updateSelectionLabel();
            draw();
        } else {
            selectedId = null;
            selectedCircleId = null;
            activeSectionIds = null;
            sectionInitialPositions.clear();
            viewPanning = false;
            updateSelectionLabel();
            if (event.button === 0) {
                viewPanning = true;
                panPointerStart = { x: event.clientX, y: event.clientY };
                panStart = { x: pan.x, y: pan.y };
                canvas.setPointerCapture(event.pointerId);
                event.preventDefault();
            }
            draw();
        }
    });

    canvas.addEventListener('pointermove', event => {
        if (draggingCircleId) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const { x, y } = canvasToMm(event.clientX - rect.left, event.clientY - rect.top);
            const circle = getCircleById(draggingCircleId);
            if (circle) {
                circle.x = x - circleDragOffset.x;
                circle.y = y - circleDragOffset.y;
                draw();
            }
            return;
        }
        if (viewPanning) {
            event.preventDefault();
            const dx = event.clientX - panPointerStart.x;
            const dy = event.clientY - panPointerStart.y;
            pan.x = panStart.x + dx;
            pan.y = panStart.y + dy;
            clampPan();
            draw();
            return;
        }
        if (!dragging || !selectedId) { return; }
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        const rect = canvas.getBoundingClientRect();
        const { x, y } = canvasToMm(event.clientX - rect.left, event.clientY - rect.top);
        const initial = sectionInitialPositions.get(selectedId) || { x: placement.x, y: placement.y };
        const targetX = x - dragOffset.x;
        const targetY = y - dragOffset.y;
        const deltaX = targetX - initial.x;
        const deltaY = targetY - initial.y;
        const ids = activeSectionIds ? Array.from(activeSectionIds) : [selectedId];
        ids.forEach(id => {
            const piece = getPlacementById(id);
            const start = sectionInitialPositions.get(id);
            if (!piece || !start) { return; }
            piece.x = start.x + deltaX;
            piece.y = start.y + deltaY;
        });
        draw();
    });

    canvas.addEventListener('pointerup', event => {
        if (canvas.hasPointerCapture(event.pointerId)) {
            canvas.releasePointerCapture(event.pointerId);
        }
        let shouldEmit = false;
        if (dragging) {
            dragging = false;
            activeSectionIds = null;
            sectionInitialPositions.clear();
            shouldEmit = true;
        }
        if (viewPanning) {
            viewPanning = false;
            shouldEmit = true;
        }
        if (draggingCircleId) {
            draggingCircleId = null;
            renderCircleList();
            shouldEmit = true;
        }
        if (shouldEmit) {
            emitState();
        }
    });

    canvas.addEventListener('pointercancel', event => {
        if (canvas.hasPointerCapture(event.pointerId)) {
            canvas.releasePointerCapture(event.pointerId);
        }
        let shouldEmit = false;
        if (dragging) {
            dragging = false;
            activeSectionIds = null;
            sectionInitialPositions.clear();
            shouldEmit = true;
        }
        if (viewPanning) {
            viewPanning = false;
            shouldEmit = true;
        }
        if (draggingCircleId) {
            draggingCircleId = null;
            renderCircleList();
            shouldEmit = true;
        }
        if (shouldEmit) {
            emitState();
        }
    });

    canvas.addEventListener('wheel', event => {
        event.preventDefault();
        if (event.ctrlKey || event.metaKey) {
            const rect = canvas.getBoundingClientRect();
            const focus = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top,
            };
            const zoomFactor = Math.exp(-event.deltaY * 0.0015);
            setZoom(zoom * zoomFactor, focus);
        } else {
            pan.x -= event.deltaX;
            pan.y -= event.deltaY;
            clampPan();
            draw();
        }
    }, { passive: false });

    function hitTest(placement, x, y) {
        const piece = libraryByCode[placement.code];
        if (!piece) { return false; }
        const rotation = (placement.rotation || 0) * Math.PI / 180;
        const dx = x - placement.x;
        const dy = y - placement.y;
        const cos = Math.cos(rotation);
        const sin = Math.sin(rotation);
        const localX = cos * dx + sin * dy;
        const localY = -sin * dx + cos * dy;
        if (piece.kind === 'curve' && piece.radius) {
            const dist = Math.sqrt(dx * dx + dy * dy);
            return Math.abs(dist - piece.radius) < 60;
        }
        const length = piece.displayLength || piece.length || 0;
        return Math.abs(localX) <= length / 2 && Math.abs(localY) <= 50;
    }

    function adjustSelected(deltaRotation = 0, deltaX = 0, deltaY = 0) {
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        const pivot = { x: placement.x, y: placement.y };
        const sectionIds = sectionMode ? connectedSectionIds(selectedId) : [selectedId];
        applySectionTransform(sectionIds, pivot, deltaRotation, deltaX, deltaY);
        draw();
        emitState();
    }

    document.getElementById('rotateLeft').addEventListener('click', () => adjustSelected(-15, 0, 0));
    document.getElementById('rotateRight').addEventListener('click', () => adjustSelected(15, 0, 0));
    document.getElementById('nudgeUp').addEventListener('click', () => adjustSelected(0, 0, 10));
    document.getElementById('nudgeDown').addEventListener('click', () => adjustSelected(0, 0, -10));
    document.getElementById('nudgeLeft').addEventListener('click', () => adjustSelected(0, -10, 0));
    document.getElementById('nudgeRight').addEventListener('click', () => adjustSelected(0, 10, 0));
    document.getElementById('flipPiece').addEventListener('click', () => {
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        placement.flipped = !placement.flipped;
        draw();
        emitState();
    });

    document.getElementById('snapGrid').addEventListener('click', () => {
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        const targetX = Math.round(placement.x / 10) * 10;
        const targetY = Math.round(placement.y / 10) * 10;
        const targetRotation = Math.round((placement.rotation || 0) / 15) * 15;
        const deltaX = targetX - placement.x;
        const deltaY = targetY - placement.y;
        const deltaRotation = normalizeDegrees(targetRotation - (placement.rotation || 0));
        const pivot = { x: placement.x, y: placement.y };
        const sectionIds = sectionMode ? connectedSectionIds(selectedId) : [selectedId];
        applySectionTransform(sectionIds, pivot, deltaRotation, deltaX, deltaY);
        const updatedPlacement = getPlacementById(selectedId);
        if (updatedPlacement) {
            updatedPlacement.rotation = ((targetRotation % 360) + 360) % 360;
        }
        draw();
        emitState();
    });

    document.getElementById('snapPiece').addEventListener('click', () => {
        const placement = getPlacementById(selectedId);
        if (!placement) { return; }
        const transform = findBestSnapTransform(placement);
        if (!transform) { return; }
        const pivot = { x: placement.x, y: placement.y };
        const sectionIds = sectionMode ? connectedSectionIds(selectedId) : [selectedId];
        applySectionTransform(sectionIds, pivot, transform.deltaRotationDeg, transform.deltaX, transform.deltaY);
        draw();
        emitState();
    });

    const sectionToggleButton = document.getElementById('toggleSectionMode');

    function updateSectionToggleButton() {
        if (!sectionToggleButton) { return; }
        sectionToggleButton.textContent = sectionMode ? 'Section move: On' : 'Section move: Off';
        sectionToggleButton.classList.toggle('primary', sectionMode);
    }

    if (sectionToggleButton) {
        sectionToggleButton.addEventListener('click', () => {
            sectionMode = !sectionMode;
            if (!sectionMode) {
                activeSectionIds = null;
                sectionInitialPositions.clear();
            }
            updateSectionToggleButton();
        });
    }
    document.getElementById('deletePiece').addEventListener('click', () => {
        if (selectedCircleId) {
            const circleIndex = guideCircles.findIndex(circle => circle.id === selectedCircleId);
            if (circleIndex !== -1) {
                guideCircles.splice(circleIndex, 1);
                selectedCircleId = guideCircles.length ? guideCircles[guideCircles.length - 1].id : null;
                renderCircleList();
                updateSelectionLabel();
                draw();
                emitState();
                return;
            }
        }
        const index = placements.findIndex(p => p.id === selectedId);
        if (index === -1) { return; }
        placements.splice(index, 1);
        selectedId = placements.length ? placements[placements.length - 1].id : null;
        activeSectionIds = null;
        sectionInitialPositions.clear();
        updateSelectionLabel();
        draw();
        emitState();
    });

    function renderCircleList() {
        const list = document.getElementById('circleList');
        if (!list) { return; }
        if (!guideCircles.length) {
            list.innerHTML = '<p class="hint">No planning circles added yet.</p>';
            requestFrameHeight();
            return;
        }
        const entries = guideCircles.map(circle => {
            const selected = circle.id === selectedCircleId ? ' selected' : '';
            const label = circle.label || `Radius ${circle.radius.toFixed(0)} mm`;
            const position = `Centre ${circle.x.toFixed(0)} mm Â· ${circle.y.toFixed(0)} mm`;
            const colour = circle.color || '#ff7f0e';
            return `
                <div class="circle-item${selected}" data-id="${circle.id}">
                    <span class="circle-swatch" style="background:${colour}"></span>
                    <div class="circle-meta">
                        <div><strong>${label}</strong></div>
                        <div>${position}</div>
                    </div>
                    <div class="circle-actions">
                        <button type="button" data-action="remove" data-id="${circle.id}">Remove</button>
                    </div>
                </div>
            `;
        });
        list.innerHTML = entries.join('');
        list.querySelectorAll('.circle-item').forEach(item => {
            item.addEventListener('click', () => {
                const id = item.getAttribute('data-id');
                if (!id) { return; }
                selectedCircleId = id;
                selectedId = null;
                updateSelectionLabel();
                renderCircleList();
                draw();
                emitState();
            });
        });
        list.querySelectorAll('button[data-action="remove"]').forEach(button => {
            button.addEventListener('click', event => {
                event.stopPropagation();
                const id = event.currentTarget.getAttribute('data-id');
                const index = guideCircles.findIndex(circle => circle.id === id);
                if (index !== -1) {
                    guideCircles.splice(index, 1);
                    if (selectedCircleId === id) {
                        selectedCircleId = guideCircles.length ? guideCircles[guideCircles.length - 1].id : null;
                    }
                    renderCircleList();
                    updateSelectionLabel();
                    draw();
                    emitState();
                }
            });
        });
        requestFrameHeight();
    }

    const saveLayoutButton = document.getElementById('saveLayout');
    if (saveLayoutButton) {
        saveLayoutButton.addEventListener('click', () => {
            const payload = emitState();
            const jsonText = JSON.stringify(payload, null, 2);
            const blob = new Blob([jsonText], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `layout-${timestamp}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        });
    }

    if (window.Streamlit && window.Streamlit.events && window.Streamlit.RENDER_EVENT) {
        window.Streamlit.events.addEventListener(window.Streamlit.RENDER_EVENT, event => {
            const detail = event && event.detail ? event.detail : {};
            applyRenderArgs(detail.args || {});
        });
    } else {
        window.addEventListener('message', event => {
            if (event && event.data && event.data.type === 'streamlit:render') {
                applyRenderArgs(event.data.args || {});
            }
        });
    }

    window.addEventListener('resize', () => {
        resizeCanvas();
        requestFrameHeight();
    });
    resizeCanvas();
    updateSelectionLabel();
    updateSectionToggleButton();
    renderCircleList();
    requestFrameHeight();
    announceReady();
    </script>
    